<html><body><div class="section_box" data-v-4f9376c5="" id="section_0" style="min-height: 674px; background-color: rgb(255, 255, 255); font-size: 16px;"><div class="frontCover"><img data-is-loaded="true" height="974" src="./images/cover.jpg" style="vertical-align: middle; width: 700px; height: 974px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div></div><div class="section_box" data-v-4f9376c5="" id="section_1" style="min-height: 674px; background-color: rgb(255, 255, 255); font-size: 16px;">
<p class="tg-title">OpenCV编程案例详解</p>
<p class="tg-author">李立宗　著</p>
<p class="tg-pub">电子工业出版社</p>
<p class="content_100">Publishing House of Electronics Industy</p>
<p class="content_100">北京·BEIJING</p>
</div><div class="section_box" data-v-4f9376c5="" id="section_2" style="min-height: 674px; background-color: rgb(255, 255, 255); font-size: 16px;">
<p class="content_101">内容简介</p>
<p class="content" style="text-indent:2em;">OpenCV是英特尔（Intel）公司发起的一个开源应用平台，借助该平台能够开发高效的计算机视觉应用项目。本书以实例介绍了如何使用OpenCV构建计算机视觉系统，本文的系统主要包括常用函数介绍类系统和应用类系统两类。常用函数介绍类系统以介绍函数的使用为主。在这类系统中主要介绍了常用OpenCV函数的使用方法，并对这些函数进行了不同形式的参数调用。应用类系统尝试解决一些实际问题，用最简单的方法实现一个学习系统，让读者能够了解该类系统的主要算法、解决问题的基本思路，同时能够更深入地了解如何更好地使用OpenCV处理实际问题。本书各章的内容相对独立，因此不需要按照顺序从第1章开始阅读，读者可以自由选择自己感兴趣的内容来学习。本书中的全部系统均以当前的最新版本OpenCV3.0版本进行介绍。本书在处理问题时，尽量屏蔽了无关的细节，即将OpenCV作为一个黑盒来使用。</p>
<p class="content" style="text-indent:2em;">本书提供的教学系统能够让读者快速掌握计算机视觉的相关知识，尽快掌握图像处理的相关算法和系统构建，让图像处理的零基础入门开发者能够尽快成为一名从业人员。本书提供的学习系统均含有详细的注释，读者能够在具有一定C++开发基础、图像处理零基础的情况下完全自主地进行自学。本书能够为在校学生、教师、入门者、专业人员、爱好者等不同身份的读者提供参考。</p>
<p class="content" style="text-indent:2em;">未经许可，不得以任何方式复制或抄袭本书之部分或全部内容。</p>
<p class="content" style="text-indent:2em;">版权所有，侵权必究。</p>
<p class="content" style="text-indent:2em;"><span style="font-weight: bold;">图书在版编目（CIP）数据</span></p>
<p class="content" style="text-indent:2em;">OpenCV编程案例详解/李立宗著.—北京：电子工业出版社，2016.10</p>
<p class="content" style="text-indent:2em;">ISBN　978-7-121-29952-0</p>
<p class="content" style="text-indent:2em;">Ⅰ.①O…　Ⅱ.①李…　Ⅲ.①图象处理软件—程序设计　Ⅳ.①TP391.41</p>
<p class="content" style="text-indent:2em;">中国版本图书馆CIP数据核字（2016）第228485号</p>
<p class="content" style="text-indent:2em;">策划编辑：符隆美</p>
<p class="content" style="text-indent:2em;">责任编辑：付睿</p>
<p class="content" style="text-indent:2em;">印刷：</p>
<p class="content" style="text-indent:2em;">装订：</p>
<p class="content" style="text-indent:2em;">出版发行：电子工业出版社　北京市海淀区万寿路173信箱</p>
<p class="content" style="text-indent:2em;">邮编　100036</p>
<p class="content" style="text-indent:2em;">开本：787×1092　1/16</p>
<p class="content" style="text-indent:2em;">印张：31.25</p>
<p class="content" style="text-indent:2em;">字数：715千字</p>
<p class="content" style="text-indent:2em;">版次：2016年10月第1版</p>
<p class="content" style="text-indent:2em;">印次：2016年10月第1次印刷</p>
<p class="content" style="text-indent:2em;">定价：89.00元</p>
<p class="content" style="text-indent:2em;">凡所购买电子工业出版社图书有缺损问题，请向购买书店调换。若书店售缺，请与本社发行部联系，联系及邮购电话：（010）88254888，88258888。</p>
<p class="content" style="text-indent:2em;">质量投诉请发邮件至zlts@phei.com.cn，盗版侵权举报请发邮件至dbqq@phei.com.cn。</p>
<p class="content" style="text-indent:2em;">本书咨询联系方式：010-51260888-819　faq@phei.com.cn。</p>
</div><div class="section_box" data-v-4f9376c5="" id="section_3" style="min-height: 674px; background-color: rgb(255, 255, 255); font-size: 16px;">
<h1 class="firstTitle">前言</h1>
<p class="content" style="text-indent:2em;">计算机视觉技术是在图像处理技术上发展起来的一门学科，在很多领域发挥着非常关键的作用。随着硬件设备的不断升级及价格的不断下降，计算机视觉技术越来越成熟。OpenCV是英特尔（Intel）公司发起的一个开源应用平台，借助该工具能够开发高效的计算机视觉应用项目。</p>
<p class="content_102">内容</p>
<p class="content" style="text-indent:2em;">本书的系统主要包括常用函数介绍类系统和应用类系统两类。</p>
<p class="content" style="text-indent:2em;">●常用函数介绍类系统</p>
<p class="content" style="text-indent:2em;">这类系统以介绍函数的使用为主，包括图像处理系统（第1章）、医学图像处理系统（第2章）、图像边缘检测学习系统（第3章）。这些系统主要介绍了常用OpenCV函数的使用方法，并对这些函数进行了不同形式的参数调用。</p>
<p class="content" style="text-indent:2em;">●应用类系统</p>
<p class="content" style="text-indent:2em;">这类系统尝试解决一些实际问题，包括数字图像加密学习系统（第4章）、手写数字识别学习系统（第5章）、骰子作画学习系统（第6章）、滤镜效果学习系统（第7章）、数字水印学习系统（第8章、第10章）和图像检索系统（第9章）。这类系统中，尝试用最简单的方法实现一个学习系统，让读者能够了解该类系统的主要算法、解决问题的基本思路，同时能够更深入地了解如何更好地使用OpenCV处理实际问题。</p>
<p class="content_102">目的</p>
<p class="content" style="text-indent:2em;">从一接触OpenCV开始，我就感受到了它的强大魅力，并深深地被它所吸引。我也希望更多的人能够了解它、更好地使用它，本书的主要目的如下。</p>
<p class="content" style="text-indent:2em;">●为OpenCV的学习提供一份更好的学习资料。</p>
<p class="content" style="text-indent:2em;">●让图像处理零基础的入门者能够快速入门。</p>
<p class="content" style="text-indent:2em;">●让学习者通过本书的学习，能够快速地构建基于OpenCV的可视化交互系统。</p>
<p class="content" style="text-indent:2em;">●通过具体的实例教程，让读者能够快速掌握图像处理的相关理论基础和算法。</p>
<p class="content" style="text-indent:2em;">●能够快速地构建基于Qt的视觉处理系统。</p>
<p class="content_102">读者范围</p>
<p class="content" style="text-indent:2em;">本书提供的教学系统能够让读者快速掌握计算机视觉的相关知识，尽快掌握图像处理的相关算法和系统构建，让图像处理的零基础入门开发者能够尽快成为一名从业人员。本书提供的学习系统均含有详细的注释，读者能够在具有一定C++开发基础、图像处理零基础的情况下完全自主地进行自学。</p>
<p class="content" style="text-indent:2em;">●在校学生</p>
<p class="content" style="text-indent:2em;">本书所介绍的系统能够方便学生自学计算机视觉相关系统的开发，也能够方便学生进行课程设计、毕业设计的学习。</p>
<p class="content" style="text-indent:2em;">●教师</p>
<p class="content" style="text-indent:2em;">本书能够作为计算机视觉相关课程的配套教材使用，也可以作为教师相关课程的教学参考书。</p>
<p class="content" style="text-indent:2em;">●入门者</p>
<p class="content" style="text-indent:2em;">对于希望进入计算机视觉领域的从业人员，本书提供的实例教程能够让他们快速掌握图像处理的相关理论基础、算法、设计思路等内容。</p>
<p class="content" style="text-indent:2em;">●专业人员</p>
<p class="content" style="text-indent:2em;">对计算机视觉处理领域的专业人员，本书大量的实例代码能够让他们快速上手相关项目，为他们提供切实有效的帮助。</p>
<p class="content" style="text-indent:2em;">●爱好者</p>
<p class="content" style="text-indent:2em;">对计算机视觉处理有兴趣的爱好者，能够根据本书提供的系统完成相关项目的开发工作。由于本书屏蔽了很多内部细节，因此能够让爱好者更好地实现系统。</p>
<p class="content_102">特点</p>
<p class="content" style="text-indent:2em;">本书不需要按照顺序从第1章开始阅读，读者可以选择自己感兴趣的内容，各章的内容相对独立。本书中的全部系统均以当前的最新版本OpenCV 3.0进行介绍。</p>
<p class="content" style="text-indent:2em;">●用Qt构建可视化系统</p>
<p class="content" style="text-indent:2em;">目前，针对OpenCV的学习教程大部分局限在函数的使用上。本书将OpenCV的函数进行了整合，使用Qt构建了多种不同形式的图像处理系统来介绍函数的使用、图像处理常用算法、系统如何构建等。书中介绍的系统分成基础系统和实用性系统。基础系统主要介绍OpenCV常用函数的具体使用，给出了函数在调用不同参数时的实现效果。实用性系统尝试解决一些常见的问题，比如手写数字识别、图像检索、图像加密、数字水印、图像隐藏、滤镜效果等。</p>
<p class="content" style="text-indent:2em;">●黑盒</p>
<p class="content" style="text-indent:2em;">本书在进行图像处理的过程中，把OpenCV函数作为一个黑盒来使用，尽可能使用通俗易懂的语言来描述图像处理算法要实现什么功能、需要使用什么参数，而尽量避免堆砌复杂的公式来描述实现细节信息，尽可能地屏蔽了其内部实现细节。同时，为了更好地了解函数的功能，本书中使用了大量的具体示例对函数的实际处理效果进行了展示。</p>
<p class="content" style="text-indent:2em;">●简化问题处理</p>
<p class="content" style="text-indent:2em;">在处理问题时，本书尽可能地将问题进行了简化处理。例如在进行数字识别时，采用了最近邻算法。所使用的特征图像库中，针对每一个数字仅仅存储有一个特征图像。在数字识别时，将待识别的数字图像与图像库中的图像进行特征比对，将与其特征最接近的特征图像作为识别结果。这样，极大地简化了问题的处理。通过这一系统的学习，既掌握了处理问题的基本思路和方法，又掌握了OpenCV的使用。</p>
<p class="content" style="text-indent:2em;">●问题处理尽量独立</p>
<p class="content" style="text-indent:2em;">在数字图像处理过程中，处理过程的各个处理步骤、流程之间往往存在着较强的相关性，还有一些处理过程之间存在着较大的相似性。因此，在实际处理过程中，往往需要构建多个自定义函数，也就存在着较多的函数调用。本书在实现的过程中，为了方便问题的理解，更多关注OpenCV的使用，尽量将一个处理作为一个独立的单元来实现，避免了由过于复杂的函数调用带来的学习干扰。</p>
<p class="content" style="text-indent:2em;">●章节之间相互独立</p>
<p class="content" style="text-indent:2em;">在本书中，以数字图像处理系统的方式介绍了十几个不同的系统。各个系统之间是独立的，读者可以从任何一章开始阅读学习。为了节省篇幅，有部分函数的介绍没有在各个不同的章节之间进行重复介绍，但相关知识点均有简单介绍，并给出了具体介绍所在的章节。</p>
<p class="content_102">感谢</p>
<p class="content" style="text-indent:2em;">首先，我要感谢我在硕士期间的导师，南开大学的高铁杠教授，高老师带我走进了计算机视觉这一领域，让我对计算机视觉产生了浓厚的兴趣。同时感谢高老师长期以来，尤其是在我毕业后，还保持对我的关心和指导。</p>
<p class="content" style="text-indent:2em;">感谢CSDN提供的博客服务，让我在学习时有坚持下去的动力。对于我来说，学习知识的过程是漫长的、枯燥的，自己一个人很难持续地坚持学习。但是当我学习了新知识在CSDN上面发表博文后，看到阅读量不断增多，我知道还有很多同学和我一样奋斗在同样的知识点上，就增加了坚持下去的信心。更应该感谢CSDN让我有缘和符隆美老师结识，才有了这本书的出版。</p>
<p class="content" style="text-indent:2em;">感谢于仕琪、刘瑞祯两位老师出版的OpenCV的教程，领我进入了OpenCV这一技术领域。</p>
<p class="content" style="text-indent:2em;">感谢英特尔公司OpenCV团队提供了如此优秀的工具、非常优秀的官网。感谢官网提供的大量优质学习资源，本书中所介绍的函数语法参考了官网上的大量资料。</p>
<p class="content" style="text-indent:2em;">非常感谢本书的编辑付睿老师对稿件做出的修改，将我许多本来晦涩不通的语句变得能够达到出版的要求，并对存在的技术问题进行了修正，同时感谢为本书出版而付出辛勤工作的各位同仁。更要特别感谢符隆美老师，感谢符老师为出版本书所付出的辛勤工作，感谢符老师在写作过程中给予我的关心和帮助。</p>
<p class="content" style="text-indent:2em;">感谢我的工作单位天津职业技术师范大学，感谢单位对我开发OpenCV相关系统所给予的支持和资助。本书受到天津职业技术师范大学科研发展基金（编号：KJ12-12）的资助。</p>
<p class="content" style="text-indent:2em;">感谢合作单位天津远目科技有限公司对本书编写工作所提供的帮助和支持。</p>
<p class="content" style="text-indent:2em;">最后，我要感谢家人的支持。在完成本书期间，我经常独自一人闷在书房里而忽略了你们的感受，也逃避了很多责任。我要感谢你们一直以来对我的理解、支持、付出，你们是我不断前行的动力，我爱你们！</p>
<p class="content_102">互动方式</p>
<p class="content" style="text-indent:2em;">由于本人水平有限，虽然本书经过了多次校验，但是肯定仍旧存在很多大大小小的问题，希望读者朋友在使用本书时，能够海涵。在出版后，我会针对读者朋友提供的反馈信息进行整理、归纳，给出统一的勘误表。本书中所介绍的全部系统目前均已经能够在Windows 10系统下正常稳定地运行，需要书中系统的读者请与我联系，以获取书中的教学案例系统。我也在准备本书所介绍系统的配套视频教程，完成后会通过多种渠道发布，欢迎大家关注。也非常欢迎大家跟我交流关于OpenCV的各种问题。</p>
<p class="content" style="text-indent:2em;">我的联系方式如下。</p>
<p class="content" style="text-indent:2em;">qq群：303230397</p>
<p class="content" style="text-indent:2em;">邮箱：lilizong@gmail.com</p>
<p class="content" style="text-indent:2em;">如果读者需要案例源代码、勘误等资料，请发送邮件至上述邮箱，来信时请在邮件标题中写明书名《OpenCV编程案例详解》。</p>
<p class="content_103">李立宗</p>
<p class="content_103">2016年5月23日</p>
</div><div class="section_box" data-v-4f9376c5="" id="section_4" style="min-height: 674px; background-color: rgb(255, 255, 255); font-size: 16px;"><h1 class="firstTitle">第1章 图像处理系统</h1><p class="content" style="text-indent:2em;">数字图像的典型处理有翻转、形态学处理、滤波、缩放、旋转等，是图像处理的基础。只有掌握这些图像处理方法，才能够进一步进行更为复杂的图像处理。本章主要实现了一个简单的图像处理系统，系统内主要实现数字图像的翻转、形态学处理、滤波处理、缩放、旋转等基本的图像处理功能。</p><h2 class="secondTitle" id="bw1">1.1 系统介绍</h2><p class="content" style="text-indent:2em;">系统采用 OpenCV 3.0 在 Qt Creator 内开发，为了让读者能够更好地掌握OpenCV 3.0的函数并了解Qt开发的基本原理，本系统在实现的过程中，尽量将每一个处理作为一个独立单元实现。</p><h3 class="thirdTitle" id="bw2">1.1.1 功能描述</h3><p class="content" style="text-indent:2em;">本系统实现了数字图像处理中的翻转、形态学处理、滤波处理、缩放、旋转等功能。系统内各个功能的实现均采用了OpenCV 3.0的函数实现。</p><p class="content" style="text-indent:2em;">图像的翻转实现了图像在水平、垂直、垂直水平同步等不同形式的翻转。形态学实现了腐蚀、膨胀、开运算、闭运算、Morphological Gradient（形态学梯度）、顶帽、黑帽等多种形式的处理。滤波实现了均值、方框、高斯、中值、双边等不同形式的滤波。缩放部分分别采用pyrUp、pyrDown、resize实现了图像的放大和缩小显示。旋转部分实现了图像顺时针无缩放、顺时针缩放、逆时针、零旋转缩放等多种不同形式的变换。</p><h3 class="thirdTitle" id="bw3">1.1.2 总体结构</h3><p class="content" style="text-indent:2em;">系统的总体结构如图1-1所示。</p><div class="pic"><img data-is-loaded="true" height="313" src="./images/29952-0015-0001.jpg" style="vertical-align: middle; width: 700px; height: 313px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/><p class="imgtitle" style="text-align:center;">图1-1 系统的总体结构</p></div><p class="content" style="text-indent:2em;">界面效果如图1-2所示，左侧显示源图像，右侧显示处理后的目标图像。</p><div class="pic"><img data-is-loaded="true" height="363" src="./images/29952-0016-0002.jpg" style="vertical-align: middle; width: 548px; height: 363px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="548"/><p class="imgtitle" style="text-align:center;">图1-2 界面效果</p></div><h2 class="secondTitle" id="bw4">1.2 系统原理</h2><p class="content" style="text-indent:2em;">图像处理效果的实现主要采用OpenCV 3.0的函数实现，下面对使用到的函数做简单介绍。</p><h3 class="thirdTitle" id="bw5">1.2.1 翻转</h3><p class="content" style="text-indent:2em;">图像的翻转采用 flip 函数实现，该函数能够实现图像在水平方向翻转、垂直方向翻转、两个方向同时翻转，其语法结构为：</p><p class="content_104">void cv::flip （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">int flipCode）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：是要处理的原始图像。</p><p class="content" style="text-indent:2em;">●dst：是和原始图像具有同样大小、类型的目标图像。</p><p class="content" style="text-indent:2em;">●flipCode：是旋转类型。该参数的意义如表1-1所示。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表1-1 flipCode参数意义</p><img data-is-loaded="true" height="144" src="./images/29952-0016-0003.jpg" style="vertical-align: middle; width: 700px; height: 144px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><p class="content" style="text-indent:2em;">该函数中，目标像素点与原始像素点的关系表述为：</p><div class="bodyPic_107"><img data-is-loaded="true" height="136" src="./images/29952-0016-0004.jpg" style="vertical-align: middle; width: 567px; height: 136px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="567"/></div><p class="content" style="text-indent:2em;">其中，dst是目标像素点，src是原始像素点。</p><h3 class="thirdTitle" id="bw6">1.2.2 形态学处理</h3><p class="content" style="text-indent:2em;">形态学，即数学形态学（Mathematical Morphology），是图像处理过程中非常重要的一个研究方向。形态学主要从图像内提取其分量信息，该分量信息通常对于表达和描绘图像的形状具有重要的意义，通常是图像理解时所使用的最为本质的形状特征。例如，在处理手写数字识别时，能够通过形态学运算得到其骨架信息，在具体识别时，仅针对其骨架进行运算即可。形态学处理在视觉检测、文字识别、医学图像处理、图像压缩编码等领域都有着非常重要的应用。</p><p class="content" style="text-indent:2em;">这部分主要包含：腐蚀、膨胀、开运算、闭运算、Morphological Gradient（形态学梯度）、顶帽、黑帽等操作。</p><p class="content_102">1.腐蚀</p><p class="content" style="text-indent:2em;">腐蚀是最基本的形态学操作之一，它能够将图像的边界点消除，使图像沿着边界向内收缩，也可以将小于指定结构体元素的部分去除。二值图像的腐蚀示例效果如图1-3所示。</p><div class="pic"><img data-is-loaded="true" height="261" src="./images/29952-0017-0005.jpg" style="vertical-align: middle; width: 407px; height: 261px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="407"/><p class="imgtitle" style="text-align:center;">图1-3 腐蚀效果</p></div><p class="content" style="text-indent:2em;">在OpenCV 3.0内采用erode函数实现对图像的腐蚀，该函数采用一个特定的结构来完成腐蚀操作。函数的语法结构为：</p><p class="content_104">void cv::erode （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">InputArray kernel,</p><p class="content_105">Point anchor=Point（-1,-1）,</p><p class="content_105">int iterations=1,</p><p class="content_105">int borderType=BORDER_CONSTANT,</p><p class="content_105">const Scalar&amp; borderValue=morphologyDefaultBorderValue（） ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：需要进行腐蚀的原始输入图像，图像的通道数可以是任意的，但是要求图像的深度必须是CV_8U、CV_16U、CV_16S、CV_32F、CV_64F其中的一种。</p><p class="content" style="text-indent:2em;">●dst：被腐蚀后所输出的目标图像，该图像和原始图像具有同样的类型和大小。</p><p class="content" style="text-indent:2em;">●kernel：腐蚀操作时所采用的结构类型，如果element=Mat（），则使用一个3×3的核。它可以通过函数getStructuringElement（）生成。</p><p class="content" style="text-indent:2em;">●anchor：element结构中锚点的位置。该值默认为（-1,-1），在核的中心位置。</p><p class="content" style="text-indent:2em;">●iterations：腐蚀操作迭代的次数，该值默认为1，即只进行一次腐蚀操作。</p><p class="content" style="text-indent:2em;">●borderType：图像边界处理方法，一般采用其默认值BORDER_CONSTANT。该项的具体值如表1-2所示。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表1-2 borderType值</p><img data-is-loaded="true" height="331" src="./images/29952-0018-0006.jpg" style="vertical-align: middle; width: 700px; height: 331px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><p class="content" style="text-indent:2em;">●borderValue：边界值，一般采用其默认值morphologyDefaultBorderValue（）。</p><p class="content" style="text-indent:2em;">其中，所调用的函数morphologyDefaultBorderValue（）用来返回腐蚀和膨胀的“魔力（magic）”边界值。它通常自动转换为Scalar::all（-DBL_MAX）进行膨胀。</p><p class="content" style="text-indent:2em;">其参数中的kernel可以通过调用getStructuringElement得到，其定义形式为：</p><p class="content_104">Mat cv::getStructuringElement（</p><p class="content_105">int shape,</p><p class="content_105">Size ksize,</p><p class="content_105">Point anchor = Point（-1,-1） ）</p><p class="content" style="text-indent:2em;">该函数用来返回一个用于形态学操作的指定大小和形状的结构元素。</p><p class="content" style="text-indent:2em;">该函数能够构造并返回一个用于cv::erode、cv::dilate或cv::morphologyEx的结构元素。当然，除了使用该函数外，用户也可以自己构建任意二进制掩码作为形态学操作中所使用的结构元素。</p><p class="content" style="text-indent:2em;">函数中的参数含义如下。</p><p class="content" style="text-indent:2em;">●shape：cv::MorphShapes中的任意一个元素形状。其可能的取值如表1-3所示。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表1-3 形状类型</p><img data-is-loaded="true" height="140" src="./images/29952-0018-0007.jpg" style="vertical-align: middle; width: 700px; height: 140px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><p class="content" style="text-indent:2em;">●ksize：结构元素的大小。</p><p class="content" style="text-indent:2em;">●anchor：结构元素中的锚点位置。默认的值是（-1,-1），是形状的中心。仅十字星型的形状与锚点位置紧密相关。在其他情况下，锚点仅用于形态学运算结果的调整。</p><p class="content_102">2.膨胀</p><p class="content" style="text-indent:2em;">膨胀操作是形态学中另外一种最基本的操作。膨胀操作和腐蚀操作的作用是相反的，它是对图像的边界进行扩张，将与当前对象接触到的背景点合并到图像内，让边界点向外部进行扩张。如果图像内两个对象的距离较近，在膨胀的过程中，两个对象可能会连通到一起。膨胀操作对填补图像分割后图像内所存在的空白相当有帮助。二值图像的膨胀示例如图1-4所示。</p><div class="pic"><img data-is-loaded="true" height="242" src="./images/29952-0019-0008.jpg" style="vertical-align: middle; width: 372px; height: 242px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="372"/><p class="imgtitle" style="text-align:center;">图1-4 二值图像的膨胀示例</p></div><p class="content" style="text-indent:2em;">在OpenCV 3.0内，采用dilate函数实现对图像的膨胀操作，该函数的语法结构为：</p><p class="content_104">void cv::dilate （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">InputArray kernel,</p><p class="content_105">Point anchor=Point（-1,-1）,</p><p class="content_105">int iterations=1,</p><p class="content_105">int borderType=BORDER_CONSTANT,</p><p class="content_105">const Scalar&amp; borderValue=morphologyDefaultBorder</p><p class="content_105">Value（） ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：需要进行膨胀操作的原始图像。图像的通道数可以是任意的，但是要求图像的深度必须是CV_8U、CV_16U、CV_16S、CV_32F、CV_64F其中的一种。</p><p class="content" style="text-indent:2em;">●dst：被膨胀后所输出的目标图像，该图像和原始图像具有同样的类型和大小。</p><p class="content" style="text-indent:2em;">●element：腐蚀操作时所采用的结构类型，默认为一个3×3的核。</p><p class="content" style="text-indent:2em;">●参数kernel、anchor、iterations、borderType、borderValue与erode函数的意义一致。</p><p class="content_102">3.morphologyEx运算</p><p class="content" style="text-indent:2em;">腐蚀操作和膨胀操作是形态学运算的基础，将腐蚀和膨胀操作结合，就可以实现开运算、闭运算、Morphological Gradient（形态学梯度）、顶帽运算、黑帽运算、击中击不中等不同形式的运算。在OpenCV 3.0内提供了morphologyEx函数实现上述形态学运算。其语法结构如下：</p><p class="content_104">void cv::morphologyEx （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">int op,</p><p class="content_105">InputArray kernel,</p><p class="content_105">Point anchor=Point（-1,-1）,</p><p class="content_105">int iterations=1,</p><p class="content_105">int borderType=BORDER_CONSTANT,</p><p class="content_105">const Scalar&amp; borderValue=morphologyDefault</p><p class="content_105">BorderValue（） ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：需要进行形态学操作的原始图像。图像的通道数可以是任意的，但是要求图像的深度必须是CV_8U、CV_16U、CV_16S、CV_32F、CV_64F其中的一种。</p><p class="content" style="text-indent:2em;">●dst：经过形态学处理后所输出的目标图像，该图像和原始图像具有同样的类型和大小。</p><p class="content" style="text-indent:2em;">●op：操作类型，各种形态学运算的操作规则均是将腐蚀和膨胀进行组合而得到的，具体组合方式如表1-4所示。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表1-4 op类型</p><img data-is-loaded="true" height="350" src="./images/29952-0020-0009.jpg" style="vertical-align: middle; width: 700px; height: 350px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><p class="content" style="text-indent:2em;">●参数kernel、anchor、iterations、borderType、borderValue与erode函数的意义一致。</p><h3 class="thirdTitle" id="bw7">1.2.3 滤波处理</h3><p class="content" style="text-indent:2em;">图像在采集、传输、处理的过程中通常都会存在一定的噪声干扰，噪声对于图像是一种干扰信息，使图像变得更模糊，掩盖了图像的一些特征，给图像处理带来了不便。滤波是消除图像在采集、传输和处理过程中所产生的噪声，是一项非常重要的工作。</p><p class="content" style="text-indent:2em;">在OpenCV 3.0内，滤波处理的函数主要包括：均值滤波、方框滤波、高斯滤波、中值滤波、双边滤波等。具体介绍如下。</p><p class="content_102">1.均值滤波</p><p class="content" style="text-indent:2em;">均值滤波是将当前像素周围像素点的像素平均值作为当前像素点的像素值。均值滤波采用函数blur完成，其语法形式为：</p><p class="content_104">void cv::blur （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">Size ksize,</p><p class="content_105">Point anchor=Point（-1,-1）,</p><p class="content_105">int borderType=BORDER_DEFAULT ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：输入图像，需要进行滤波处理的图像，能够被独立处理。其深度必须是CV_8U、CV_16U、CV_16S、CV_32F、CV_64F其中的一种。</p><p class="content" style="text-indent:2em;">●dst：输出图像，处理的结果图像，和原始图像src具有同样的格式和大小。</p><p class="content" style="text-indent:2em;">●ksize：滤波核的大小。</p><p class="content" style="text-indent:2em;">●anchor：锚点，默认值为（-1,-1），意味着在核的中心点位置。</p><p class="content" style="text-indent:2em;">●borderType：边界样式，默认值为BORDER_DEFAULT，具体值参考表1-2所示。</p><p class="content" style="text-indent:2em;">图像在滤波时采用的处理通常为：选取当前点周围的若干个像素点的均值，例如选取ksize为Size（3,3），则当前像素点的值为其自身及其周围像素点共计9个像素点的像素平均值，采用的滤波模板如下。</p><div class="bodyPic_107"><img data-is-loaded="true" height="86" src="./images/29952-0021-0010.jpg" style="vertical-align: middle; width: 229px; height: 86px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="229"/></div><p class="content" style="text-indent:2em;">例如，有一个像素点的值为80，其周围的像素点如图1-5所示。</p><div class="pic"><img data-is-loaded="true" height="132" src="./images/29952-0021-0011.jpg" style="vertical-align: middle; width: 535px; height: 132px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="535"/><p class="imgtitle" style="text-align:center;">图1-5 像素点示例</p></div><p class="content" style="text-indent:2em;">如果对其进行均值滤波，则其滤波值的计算方法为：</p><p class="content_100">Value=（75+193+37+121+80+189+45+94+232）/9=118</p><p class="content" style="text-indent:2em;">得到的当前的新值为118。2.方框滤波</p><p class="content" style="text-indent:2em;">方框滤波也同样采用周围像素点的平均值作为当前像素点的像素值，采用函数boxFilter完成，其语法形式为：</p><p class="content_104">void cv::boxFilter （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">int ddepth,</p><p class="content_105">Size ksize,</p><p class="content_105">Point anchor=Point（-1,-1）,</p><p class="content_105">bool normalize=true,</p><p class="content_105">int borderType=BORDER_DEFAULT ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：要滤波的原始图像。</p><p class="content" style="text-indent:2em;">●dst：滤波结果图像，与原始图像具有同样的大小和类型。</p><p class="content" style="text-indent:2em;">●ddepth：滤波输出结果的图像深度，如果该值为-1，则表示与原始图像具有同样的深度。</p><p class="content" style="text-indent:2em;">●ksize：滤波核的大小。</p><p class="content" style="text-indent:2em;">●anchor：锚点，默认值为（-1,-1），表示锚点位于核中心点。</p><p class="content" style="text-indent:2em;">●normalize：标记值，标记是否使用当前的核进行归一化处理。</p><p class="content" style="text-indent:2em;">●borderType：用来推断图像的外部像素值，具体如表1-2所示。</p><p class="content" style="text-indent:2em;">该滤波函数所使用的滤波核为：</p><p class="content" style="text-indent:2em;">K=α 1 1… …1 1 1 1 … …1 1 1 …1 …1 1… …1 1 1 1</p><p class="content" style="text-indent:2em;">其中，</p><div class="bodyPic_107"><img data-is-loaded="true" height="32" src="./images/29952-0022-0012.jpg" style="vertical-align: middle; width: 202px; height: 32px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="202"/></div><p class="content" style="text-indent:2em;">通过上述公式可以看出，当normalize的值为true时，方框滤波就是均值滤波。</p><p class="content_102">3.高斯滤波</p><p class="content" style="text-indent:2em;">均值滤波中每个像素点的权值是一致的，高斯滤波中将中心点的权值加大，远离中心点的权值减小，最后取得当前点的像素值。例如，其模板可以为：</p><div class="bodyPic_107"><img data-is-loaded="true" height="87" src="./images/29952-0022-0013.jpg" style="vertical-align: middle; width: 478px; height: 87px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="478"/></div><p class="content" style="text-indent:2em;">高斯模糊采用函数GaussianBlur完成，其语法格式为：</p><p class="content_104">void cv::GaussianBlur （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">Size ksize,</p><p class="content_105">double sigmaX,</p><p class="content_105">double sigmaY=0,</p><p class="content_105">int borderType=BORDER_DEFAULT ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：需要进行滤波的原始图像，可以是任意通道数量，能够被独立处理。但是其深度必须是CV_8U、CV_16U、CV_16S、CV_32F、CV_64F其中的一种。</p><p class="content" style="text-indent:2em;">●dst：滤波结果图像，与原始输入图像src具有同样的类型和大小。</p><p class="content" style="text-indent:2em;">●ksize：高斯计算核。核的宽度和高度可以不相同，但是它们必须都是正的奇数，或者在其为0时通过sigma的计算得到计算结果。</p><p class="content" style="text-indent:2em;">●sigmaX：表示核在x轴方向的标准偏差。</p><p class="content" style="text-indent:2em;">●sigmaY：表示核在y轴方向的标准偏差。当sigmaY为0时，表示取与sigmaX同样的值；当sigmaX和sigmaY都是0时，它们通过ksize.width和ksize.height计算而得到。为了保证滤波能够正常进行，最好将ksize、sigmaX、sigmaY进行显式赋值。</p><p class="content" style="text-indent:2em;">●borderType：边框样式，默认值为 BORDER_DEFAULT。其他可能值参考表1-2所示。</p><p class="content" style="text-indent:2em;">具体使用中，经常要用到函数cv::getGaussianKernel，该函数的语法格式为：</p><p class="content_104">Mat cv::getGaussianKernel（</p><p class="content_105">int ksize,</p><p class="content_105">double sigma,</p><p class="content_105">int ktype = CV_64F ）</p><p class="content" style="text-indent:2em;">该函数用来产生高斯滤波器的系数。</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●ksize：核大小，它应该是正的奇数。</p><p class="content" style="text-indent:2em;">●sigma：高斯标准偏差。如果不是正数，则通过计算得到。</p><p class="content" style="text-indent:2em;">●ktype：滤波器系数。它可以是CV_32F或CV_64F类型。</p><p class="content_102">4.中值滤波</p><p class="content" style="text-indent:2em;">中值滤波是取当前像素点及其周围临近像素点总共奇数个像素点，将这些像素点排序，然后将位于中间位置的值作为当前像素点的像素值。例如，当前像素点是像素值为78的位于图像中间的点，其周围像素点分布如下：</p><div class="bodyPic_107"><img data-is-loaded="true" height="85" src="./images/29952-0023-0014.jpg" style="vertical-align: middle; width: 174px; height: 85px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="174"/></div><p class="content" style="text-indent:2em;">将上述像素排序后得到[66,78,90,91,93,94,95,97,101]，该序列中处于中心位置（中心点、中值点）的值是“93”，因此用该值“93”替换掉原来的像素值“78”作为当前点的新像素值。得到：</p><div class="bodyPic_107"><img data-is-loaded="true" height="88" src="./images/29952-0023-0015.jpg" style="vertical-align: middle; width: 177px; height: 88px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="177"/></div><p class="content" style="text-indent:2em;">中值滤波采用函数medianBlur实现，具体语法格式为：</p><p class="content_104">void cv::medianBlur （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">int ksize）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：需要进行滤波的原始图像。可以是 1、3、4 通道的图像，当 ksize 大小为3或者5时，图像深度应该是CV_8U、CV_16U或CV_32F。对于大尺度图像，图像只能是CV_8U。</p><p class="content" style="text-indent:2em;">●dst：滤波处理结果图像，与原始图像src具有同样的大小和类型。</p><p class="content" style="text-indent:2em;">●ksize：核的尺度大小，必须是大于1的奇数，例如3、5、7等。</p><p class="content_102">5.双边滤波</p><p class="content" style="text-indent:2em;">双边滤波，是指有两种因素影响着滤波，一种是空间距离，一种是颜色差值范围。空间距离决定距离当前像素多远的像素能够影响当前滤波；颜色差值范围是指在当前指定空间范围内，与当前颜色的差值在多少范围内的颜色能够影响当前的滤波结果。</p><p class="content" style="text-indent:2em;">因此，在双边滤波函数内存在着两个参数，一个控制当前滤波的距离，另一个控制影响当前滤波的颜色差值（像素差值）。</p><p class="content" style="text-indent:2em;">在OpenCV 3.0内，双边滤波函数为bilateralFilter，其语法格式为：</p><p class="content_104">void cv::bilateralFilter （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">int d,</p><p class="content_105">double sigmaColor,</p><p class="content_105">double sigmaSpace,</p><p class="content_105">int borderType=BORDER_DEFAULT ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：需要滤波的原始图像，图像为8位或者浮点型单通道、三通道。</p><p class="content" style="text-indent:2em;">●dst：滤波结果图像，与原始图像具有同样的类型和大小。</p><p class="content" style="text-indent:2em;">●d：在滤波时选取的空间距离参数，这里表示以当前像素点为中心点的直径。如果该值为非正数，则会自动从参数sigmaSpace计算得到。如果滤波空间较大（d＞5），则速度会较慢。因此，在实时应用中，推荐 d=5。对于较大噪声的离线滤波，可以选择d=9。</p><p class="content" style="text-indent:2em;">●sigmaColor：在滤波时选取的颜色差值范围，该值决定了周围哪些像素点能够参与到滤波中来。与当前像素点的像素值差值小于sigmaColor的像素点，能够参与到当前的滤波中。该值越大，说明可能周围有越多的像素点参与到运算中。该值为0时，滤波失去意义；该值为255时，指定直径内所有点都能够参与运算。</p><p class="content" style="text-indent:2em;">●sigmaSpace：坐标空间中的sigma值。它的值越大，说明有越多的点能够参与到滤波计算中。在d＞0时，它指定了参数与sigmaSpace无关；否则，该参数与d值成正比。</p><p class="content" style="text-indent:2em;">其中sigma的值：为了简单起见，可以将两个sigma的值设置为相同。如果它们比较小（例如小于 10），则滤波的效果会不太明显；如果它们的值较大（例如大于150），则滤波效果会比较明显，会产生卡通效果。</p><h3 class="thirdTitle" id="bw8">1.2.4 缩放</h3><p class="content" style="text-indent:2em;">缩放是指缩小或者放大原始图像。当图像放大时，需要在原始像素点的基础上填充新增加的像素点，并对其赋予新的像素值；当图像缩小时，需要在原始图像中去掉一些像素点的像素值，或者通过对原始图像的计算而得到缩小图像内像素点的像素值。</p><p class="content" style="text-indent:2em;">图像放大时，可以采用多种方法实现像素点值填充，例如将当前像素点复制到周边的像素点，或是用当前像素点周边像素点的平均值来填充等。图像缩小时，可以直接抛弃一些像素点，也可以将原始图像划分为多个互不相交的子区域，计算各个子区域的像素平均值，用这些平均值组成一幅新的图像，即得到一幅缩小图像。对简单方式的重复、组合即可得到新的方式，提高缩放图像的质量。</p><p class="content" style="text-indent:2em;">在OpenCV 3.0内主要使用pyrUp、pyrDown、resize实现对图像的缩放。其中pyrUp和pyrDown是图像金字塔相关的两个函数，对图像进行向上采样和向下采样的操作。其本质上，实现对图像的缩放功能。</p><p class="content_102">1.pyrUp函数</p><p class="content" style="text-indent:2em;">pyrUp函数实现图像金字塔操作的向上采样，即放大功能，其语法格式如下：</p><p class="content_104">void cv::pyrUp （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">const Size&amp; dstsize=Size（）,</p><p class="content_105">int borderType=BORDER_DEFAULT ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：原始图像。</p><p class="content" style="text-indent:2em;">●dst：目标图像。它与原始图像具有相同的类型，指定的大小。</p><p class="content" style="text-indent:2em;">●dstsize：目标图像的大小。</p><p class="content" style="text-indent:2em;">●borderType：边界类型。该值的具体类型可能如表 1-2 所示。默认值为BORDER_DEFAULT，且这里仅支持BORDER_DEFAULT。</p><p class="content" style="text-indent:2em;">默认情况下，目标图像的大小为 Size（src.cols×2,src.rows×2）。在任何情况下，需要满足下列条件：</p><p class="content_100">|dst.width?src.cols × 2|≤mod（dst.widh,2）</p><p class="content_100">|dst.height?src.rows × 2|≤mod（dst.height,2）</p><p class="content_102">2.pyrDown函数</p><p class="content" style="text-indent:2em;">pyrDown函数实现图像金字塔操作的向下采样，即实现缩小功能，其语法格式为：</p><p class="content_104">void cv::pyrDown （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">const Size&amp; dstsize=Size（）,</p><p class="content_105">int borderType=BORDER_DEFAULT ）</p><p class="content" style="text-indent:2em;">其中的各个参数可以参考pyrUp中的各个参数。</p><p class="content" style="text-indent:2em;">默认情况下，输出图像大小为Size（（src.cols+1）/2,（src.rows+1）/2）。在任何情况下，必须满足如下条件：</p><p class="content_100">|dst.width × 2?src.cols|≤2</p><p class="content_100">|dst.height × 2?src.rows|≤2</p><p class="content" style="text-indent:2em;">该函数执行时，首先执行高斯变换，高斯变换的核为：</p><div class="bodyPic_107"><img data-is-loaded="true" height="145" src="./images/29952-0026-0016.jpg" style="vertical-align: middle; width: 310px; height: 145px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="310"/></div><p class="content" style="text-indent:2em;">在此基础上，它通过抛弃偶数行和列来实现缩小。</p><p class="content_102">3.resize函数</p><p class="content" style="text-indent:2em;">函数resize专门用来对图像进行缩放。其具体的语法格式为：</p><p class="content_104">void cv::resize（</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">Size dsize,</p><p class="content_105">double fx=0,</p><p class="content_105">double fy=0,</p><p class="content_105">int interpolation=INTER_LINEAR ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：需要缩放的原始图像。</p><p class="content" style="text-indent:2em;">●dst：输出的目标图像，该图像的类型与src相同，其大小为dsize（当该值非0时），或者通过src.size（）、fx、fy计算得到。</p><p class="content" style="text-indent:2em;">●dsize：输出图像大小。当该值为0时，需要通过计算获得其具体值。</p><p class="content_100">dsize=Size（round（fx×src.cols）,round（fy×src.rows））</p><p class="content" style="text-indent:2em;">该值非0，或者fx和fy均非0。</p><p class="content" style="text-indent:2em;">●fx：水平方向尺度大小。当该值是0时，需要通过计算获得其具体值。</p><p class="content_100">（double）dsize.widht/src.cols</p><p class="content" style="text-indent:2em;">●fy：垂直方向的尺度大小。当该值是0时，需要通过计算获得其具体值。</p><p class="content_100">（double）dsize.height/src.rows</p><p class="content" style="text-indent:2em;">●interpolation：插值方式，具体如表1-5所示。</p><p class="content" style="text-indent:2em;">上述参数中，目标图像的大小、长度、宽度的值不可能为0，因此将0值作为一个标记使用。当这些参数的值为0时，通过计算得到具体的大小、长度、宽度值。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表1-5 插值方式</p><img data-is-loaded="true" height="432" src="./images/29952-0027-0017.jpg" style="vertical-align: middle; width: 700px; height: 432px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><p class="content" style="text-indent:2em;">函数 resize 实现对原始图像的缩放功能，需要注意的是，开始运算前目标图像dst自身的大小和类型与最终得到的目标图像dst没有任何关系。目标图像dst的最终大小类型是通过src、dsize、fx、fy而得到的。如果想让原始图像src调整为与预先生成的目标图像dst大小匹配，则需要进行如下计算：</p><p class="content_100">resize（src, dst, dst.size（）, 0, 0, interpolation）;</p><p class="content" style="text-indent:2em;">如果想将原始图像在x轴、y轴方向的尺度均变为原来的一半，则可以使用：</p><p class="content_100">resize（src, dst, Size（）, 0.5, 0.5, interpolation）;</p><p class="content" style="text-indent:2em;">当缩小图像时，使用区域插值方式（INTER_AREA）能够得到最好的效果；当放大图像时，使用三次样条插值（INTER_CUBIC）方式和双线性插值（INTER_LINEAR）方式都能够取得较好的效果。三次样条插值方式速度较慢，双线性插值方式速度相对要快而且效果并不逊色。</p><h3 class="thirdTitle" id="bw9">1.2.5 旋转</h3><p class="content" style="text-indent:2em;">旋转实现对源图像的旋转功能，可以采用仿射操作来实现对源图像的旋转。仿射变换可以通过一系列的几何变换来实现，包括平移、缩放、翻转、旋转和错切。该变换能够保持图像的平直性和平行性。平直性是指图像经过放射后，直线仍旧是直线；平行性是指图像在完成变换后，平行线仍旧是平行线。</p><p class="content" style="text-indent:2em;">因此，可以采用仿射函数warpAffine实现对图像的旋转。在OpenCV 3.0内该函数的语法格式如下：</p><p class="content_104">void cv::warpAffine （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">InputArray M,</p><p class="content_105">Size dsize,</p><p class="content_105">int flags = INTER_LINEAR,</p><p class="content_105">int borderMode = BORDER_CONSTANT,</p><p class="content_105">const Scalar &amp; borderValue = Scalar（） ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：要旋转的图像。</p><p class="content" style="text-indent:2em;">●dst：旋转后的输出图像，该图像和原始图像具有相同的类型。dsize决定输出图像的实际大小。</p><p class="content" style="text-indent:2em;">●M：一个2×3的变换矩阵。</p><p class="content" style="text-indent:2em;">●dsize：输出图像的尺度大小。</p><p class="content" style="text-indent:2em;">●flags：插值方法，默认为INTER_LINEAR。当该值为WARP_INVERSE_MAP时，意味着M是逆变换类型，实现从目标图像dst到源图像src的逆变换。具体可选值如表1-5所示。</p><p class="content" style="text-indent:2em;">●borderMode：边类型，默认为BORDER_CONSTANT。当该值为BORDER_TRANSPARENT时，意味着目标图像内的值不做改变，这些值对应原始图像内的异常值。</p><p class="content" style="text-indent:2em;">●borderValue：边界值，默认是0。</p><h2 class="secondTitle" id="bw10">1.3 编程实现</h2><p class="content" style="text-indent:2em;">本节介绍系统的实现细节信息。</p><h3 class="thirdTitle" id="bw11">1.3.1 文件</h3><p class="content" style="text-indent:2em;">该部分的菜单如图 1-6 所示，该部分主要实现与源图像有关的图像输入、显示和文件关闭等功能。由于各章都涉及该部分的内容，因此将该部分的介绍放到了附录B内，有关该部分的具体实现细节信息请参考附录B部分，这里不再赘述。</p><div class="pic"><img data-is-loaded="true" height="323" src="./images/29952-0028-0018.jpg" style="vertical-align: middle; width: 420px; height: 323px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="420"/><p class="imgtitle" style="text-align:center;">图1-6 “文件”菜单</p></div><p class="content" style="text-indent:2em;">注意，为了节省篇幅和方便问题的说明，源文件的打开均在“文件”菜单内实现，后续操作都默认针对已经在“文件”菜单内打开了的源文件进行。</p><h3 class="thirdTitle" id="bw12">1.3.2 翻转的实现</h3><p class="content" style="text-indent:2em;">翻转部分主要实现水平、垂直、水平垂直同步旋转等共3种形式的翻转。该部分的菜单如图1-7所示。</p><div class="pic"><img data-is-loaded="true" height="197" src="./images/29952-0029-0019.jpg" style="vertical-align: middle; width: 332px; height: 197px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="332"/><p class="imgtitle" style="text-align:center;">图1-7 “翻转”菜单</p></div><p class="content_102">1.水平翻转</p><p class="content" style="text-indent:2em;">水平翻转实现在水平方向上的翻转，效果如图1-8所示。</p><div class="pic"><img data-is-loaded="true" height="369" src="./images/29952-0029-0020.jpg" style="vertical-align: middle; width: 561px; height: 369px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="561"/><p class="imgtitle" style="text-align:center;">图1-8 水平方向翻转效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_Horizen_triggered（）</p><p class="content_104">{</p><p class="content_105">//水平方向翻转</p><p class="content_105">//参数值为1</p><p class="content_105">cv::flip（srcImage,dstImage,1）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_</p><p class="content_104">RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">2.垂直翻转</p><p class="content" style="text-indent:2em;">垂直翻转实现在垂直方向上的翻转，效果如图1-9所示。</p><div class="pic"><img data-is-loaded="true" height="365" src="./images/29952-0030-0021.jpg" style="vertical-align: middle; width: 553px; height: 365px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="553"/><p class="imgtitle" style="text-align:center;">图1-9 垂直方向翻转效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_vertical_triggered（）</p><p class="content_104">{</p><p class="content_105">//垂直方向翻转</p><p class="content_105">//参数值为0</p><p class="content_105">cv::flip（srcImage,dstImage,0）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">3.水平垂直翻转</p><p class="content" style="text-indent:2em;">水平垂直翻转实现在水平方向和垂直方向上的同时翻转，效果如图1-10所示。</p><div class="pic"><img data-is-loaded="true" height="362" src="./images/29952-0030-0022.jpg" style="vertical-align: middle; width: 551px; height: 362px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="551"/><p class="imgtitle" style="text-align:center;">图1-10 水平垂直方向翻转效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_horizenAndVertical_triggered（）</p><p class="content_104">{</p><p class="content_105">//水平和垂直方向同时翻转</p><p class="content_105">//参数值为-1</p><p class="content_105">cv::flip（srcImage,dstImage,-1）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><h3 class="thirdTitle" id="bw13">1.3.3 形态学处理的实现</h3><p class="content" style="text-indent:2em;">形态学实现腐蚀、膨胀、开运算、闭运算、Morphological Gradient（形态学梯度）、顶帽、黑帽等形态学处理。该部分的菜单如图1-11所示。</p><div class="pic"><img data-is-loaded="true" height="214" src="./images/29952-0031-0023.jpg" style="vertical-align: middle; width: 302px; height: 214px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="302"/><p class="imgtitle" style="text-align:center;">图1-11 “形态”菜单</p></div><p class="content_102">1.腐蚀</p><p class="content" style="text-indent:2em;">腐蚀效果如图1-12所示。</p><div class="pic"><img data-is-loaded="true" height="354" src="./images/29952-0031-0024.jpg" style="vertical-align: middle; width: 536px; height: 354px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="536"/><p class="imgtitle" style="text-align:center;">图1-12 腐蚀效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_Erosion_triggered（）</p><p class="content_104">{</p><p class="content_105">//腐蚀操作</p><p class="content_105">//定义类型</p><p class="content_105">int erosion_type;</p><p class="content_105">erosion_type = MORPH_RECT;</p><p class="content_105">//定义大小</p><p class="content_105">int erosion_size = 3;</p><p class="content_105">//调用getStructuringElement函数</p><p class="content_105">Mat element = getStructuringElement（ erosion_type,</p><p class="content_108">Size（ 2*erosion_size + 1, 2*erosion_size+1 ）,</p><p class="content_108">Point（ erosion_size, erosion_size ） ）;</p><p class="content_105">//调用腐蚀函数</p><p class="content_105">erode（ srcImage, dstImage, element ）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_105">// imshow（"erode",dstImage）;</p><p class="content_104">}</p><p class="content_102">2.膨胀</p><p class="content" style="text-indent:2em;">膨胀效果如图1-13所示。</p><div class="pic"><img data-is-loaded="true" height="396" src="./images/29952-0032-0025.jpg" style="vertical-align: middle; width: 602px; height: 396px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="602"/><p class="imgtitle" style="text-align:center;">图1-13 膨胀效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_dialation_triggered（）</p><p class="content_104">{</p><p class="content_105">//膨胀</p><p class="content_105">//定义大小</p><p class="content_105">int dilation_size = 2;</p><p class="content_105">//定义类型</p><p class="content_105">int dilation_type;</p><p class="content_105">dilation_type = MORPH_RECT;</p><p class="content_105">//调用getStructuringElement函数</p><p class="content_105">Mat element = getStructuringElement（ dilation_type,</p><p class="content_108">Size（ 2*dilation_size + 1, 2*dilation_size+1 ）,</p><p class="content_108">Point（ dilation_size, dilation_size ） ）;</p><p class="content_105">//调用膨胀函数</p><p class="content_105">dilate（ srcImage,dstImage, element ）;</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）,QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_105">//imshow（"dialate",dstImage）;</p><p class="content_104">}</p><p class="content_102">3.开运算</p><p class="content" style="text-indent:2em;">开运算效果如图1-14所示。</p><div class="pic"><img data-is-loaded="true" height="379" src="./images/29952-0033-0026.jpg" style="vertical-align: middle; width: 574px; height: 379px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="574"/><p class="imgtitle" style="text-align:center;">图1-14 开运算效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_opening_triggered（）</p><p class="content_104">{</p><p class="content_105">//开运算</p><p class="content_105">//定义形状</p><p class="content_105">int morph_elem=MORPH_RECT;</p><p class="content_105">//定义大小</p><p class="content_105">int morph_size=3;</p><p class="content_105">//调用getStructuringElement函数</p><p class="content_105">Mat element = getStructuringElement（ morph_elem, Size（ 2*morph_size+ 1, 2*morph_size+1 ）, Point（ morph_size, morph_size ） ）;</p><p class="content_105">//调用morphologyEx函数</p><p class="content_105">morphologyEx（ srcImage, dstImage, MORPH_OPEN, element ）;</p><p class="content_105">/*</p><p class="content_108">* MORPH_OPEN - an opening operation</p><p class="content_105">MORPH_CLOSE - a closing operation</p><p class="content_105">MORPH_GRADIENT - a morphological gradient</p><p class="content_105">MORPH_TOPHAT - “top hat”</p><p class="content_105">MORPH_BLACKHAT - “black hat”</p><p class="content_105">*/</p><p class="content_105">//显示处理结果图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">4.闭运算</p><p class="content" style="text-indent:2em;">闭运算效果如图1-15所示。</p><div class="pic"><img data-is-loaded="true" height="371" src="./images/29952-0034-0027.jpg" style="vertical-align: middle; width: 565px; height: 371px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="565"/><p class="imgtitle" style="text-align:center;">图1-15 闭运算效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_closing_triggered（）</p><p class="content_104">{</p><p class="content_105">//闭运算</p><p class="content_105">//定义形状</p><p class="content_105">int morph_elem=MORPH_RECT;</p><p class="content_105">//定义大小</p><p class="content_105">int morph_size=3;</p><p class="content_105">//调用getStructuringElement函数</p><p class="content_105">Mat element = getStructuringElement（ morph_elem, Size（ 2*morph_size+ 1, 2*morph_size+1 ）, Point（ morph_size, morph_size ） ）;</p><p class="content_105">//实现闭运算</p><p class="content_105">morphologyEx（ srcImage, dstImage, MORPH_CLOSE, element ）;</p><p class="content_105">/*</p><p class="content_108">* MORPH_OPEN - an opening operation</p><p class="content_105">MORPH_CLOSE - a closing operation</p><p class="content_105">MORPH_GRADIENT - a morphological gradient</p><p class="content_105">MORPH_TOPHAT - “top hat”</p><p class="content_105">MORPH_BLACKHAT - “black hat”</p><p class="content_105">*/</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_</p><p class="content_104">RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">5.Morphological Gradient</p><p class="content" style="text-indent:2em;">Morphological Gradient（形态学梯度）效果如图1-16所示。</p><div class="pic"><img data-is-loaded="true" height="367" src="./images/29952-0035-0028.jpg" style="vertical-align: middle; width: 557px; height: 367px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="557"/><p class="imgtitle" style="text-align:center;">图1-16 Morphological Gradient效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_actionMorphological_Gradient_triggered（）</p><p class="content_104">{</p><p class="content_105">//Morphological Gradient运算</p><p class="content_105">//定义形状</p><p class="content_105">int morph_elem=MORPH_RECT;</p><p class="content_105">//定义大小</p><p class="content_105">int morph_size=3;</p><p class="content_105">//调用getStructuringElement函数</p><p class="content_105">Mat element = getStructuringElement（ morph_elem, Size（ 2*morph_size+ 1, 2*morph_size+1 ）, Point（ morph_size, morph_size ） ）;</p><p class="content_105">//实现Morphological Gradient运算</p><p class="content_105">morphologyEx（ srcImage, dstImage, MORPH_GRADIENT, element ）;</p><p class="content_105">/*</p><p class="content_108">* MORPH_OPEN - an opening operation</p><p class="content_105">MORPH_CLOSE - a closing operation</p><p class="content_105">MORPH_GRADIENT - a morphological gradient</p><p class="content_105">MORPH_TOPHAT - “top hat”</p><p class="content_105">MORPH_BLACKHAT - “black hat”</p><p class="content_105">*/</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">6.顶帽</p><p class="content" style="text-indent:2em;">顶帽效果如图1-17所示。</p><div class="pic"><img data-is-loaded="true" height="363" src="./images/29952-0036-0029.jpg" style="vertical-align: middle; width: 550px; height: 363px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="550"/><p class="imgtitle" style="text-align:center;">图1-17 顶帽效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_topHat_triggered（）</p><p class="content_104">{</p><p class="content_105">//顶帽变换</p><p class="content_105">//定义形状</p><p class="content_105">int morph_elem=MORPH_RECT;</p><p class="content_105">//定义大小</p><p class="content_105">int morph_size=3;</p><p class="content_105">//调用getStructuringElement函数</p><p class="content_105">Mat element = getStructuringElement（ morph_elem, Size（ 2*morph_size+ 1, 2*morph_size+1 ）, Point（ morph_size, morph_size ） ）;</p><p class="content_105">//设置参数为“MORPH_TOPHAT”</p><p class="content_105">morphologyEx（ srcImage, dstImage, MORPH_TOPHAT, element ）;</p><p class="content_105">/* 参数类型</p><p class="content_105">MORPH_OPEN - an opening operation</p><p class="content_105">MORPH_CLOSE - a closing operation</p><p class="content_105">MORPH_GRADIENT - a morphological gradient</p><p class="content_105">MORPH_TOPHAT - “top hat”</p><p class="content_105">MORPH_BLACKHAT - “black hat”</p><p class="content_105">*/</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）,</p><p class="content_104">QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">7.黑帽</p><p class="content" style="text-indent:2em;">黑帽效果如图1-18所示。</p><div class="pic"><img data-is-loaded="true" height="354" src="./images/29952-0037-0030.jpg" style="vertical-align: middle; width: 535px; height: 354px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="535"/><p class="imgtitle" style="text-align:center;">图1-18 黑帽效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_blackHat_triggered（）</p><p class="content_104">{</p><p class="content_105">//黑帽变换</p><p class="content_105">//定义形状</p><p class="content_105">int morph_elem=MORPH_RECT;</p><p class="content_105">//定义大小</p><p class="content_105">int morph_size=3;</p><p class="content_105">//调用getStructuringElement函数</p><p class="content_105">Mat element = getStructuringElement（ morph_elem, Size（ 2*morph_size+ 1, 2*morph_size+1 ）, Point（ morph_size, morph_size ） ）;</p><p class="content_105">//设置参数为“MORPH_BLACKHAT”</p><p class="content_105">morphologyEx（ srcImage, dstImage, MORPH_BLACKHAT, element ）;</p><p class="content_105">/* 参数类型</p><p class="content_105">MORPH_OPEN - an opening operation</p><p class="content_105">MORPH_CLOSE - a closing operation</p><p class="content_105">MORPH_GRADIENT - a morphological gradient</p><p class="content_105">MORPH_TOPHAT - “top hat”</p><p class="content_105">MORPH_BLACKHAT - “black hat”</p><p class="content_105">*/</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）,QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><h3 class="thirdTitle" id="bw14">1.3.4 滤波处理的实现</h3><p class="content" style="text-indent:2em;">滤波处理主要实现均值滤波、方框滤波、高斯滤波、中值滤波、双边滤波等。该部分的菜单如图1-19所示。</p><div class="pic"><img data-is-loaded="true" height="194" src="./images/29952-0038-0031.jpg" style="vertical-align: middle; width: 401px; height: 194px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="401"/><p class="imgtitle" style="text-align:center;">图1-19 “滤波”菜单</p></div><p class="content_102">1.均值滤波</p><p class="content" style="text-indent:2em;">均值滤波的效果如图1-20所示。</p><div class="pic"><img data-is-loaded="true" height="358" src="./images/29952-0038-0032.jpg" style="vertical-align: middle; width: 541px; height: 358px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="541"/><p class="imgtitle" style="text-align:center;">图1-20 均值滤波效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_normalizeFilter_triggered（）</p><p class="content_104">{</p><p class="content_105">//均值滤波</p><p class="content_105">//使用函数blur，设置默认值。根据需要可以调整为交互输入参数的形式</p><p class="content_105">blur（ srcImage, dstImage, Size（ 7, 7 ）, Point（-1,-1） ）;</p><p class="content_105">//显示处理结果</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">2.方框滤波</p><p class="content" style="text-indent:2em;">方框滤波分别实现了归一化处理和非归一化处理两种方式的滤波。</p><p class="content" style="text-indent:2em;">（1）归一化</p><p class="content" style="text-indent:2em;">归一化效果如图1-21所示。</p><div class="pic"><img data-is-loaded="true" height="375" src="./images/29952-0039-0033.jpg" style="vertical-align: middle; width: 567px; height: 375px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="567"/><p class="imgtitle" style="text-align:center;">图1-21 方框滤波归一化效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_normalize_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：滤波=＞方框滤波=＞归一化</p><p class="content_105">//调用boxFilter，使用默认参数，完成归一化</p><p class="content_105">boxFilter（srcImage,dstImage,-1,Size（5,5））;</p><p class="content_105">//显示处理结果</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（2）非归一化</p><p class="content" style="text-indent:2em;">非归一化的显示效果与其所选择的核大小有关系，当其核大小为Size（3,3）时，其中元素全部大于255，因此显示为白色，如图1-22所示。</p><div class="pic"><img data-is-loaded="true" height="403" src="./images/29952-0039-0034.jpg" style="vertical-align: middle; width: 613px; height: 403px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="613"/><p class="imgtitle" style="text-align:center;">图1-22 方框滤波非归一化效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_NoNormalize_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：滤波=＞方框滤波=＞非归一化</p><p class="content_105">//调用boxFilter</p><p class="content_105">//使用Size大小为Size（1,1）时，显示其原有图像</p><p class="content_105">//Size大小超过Size（3,3）时，值全部超过255，在这里显示为纯白色</p><p class="content_105">boxFilter（srcImage,dstImage,-1,Size（3,3）,Point（-1,-1）,false）;</p><p class="content_105">//显示处理结果</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">如果将其核大小调整为Size（1,1），则处理效果与源图像相同，如图1-23所示。</p><div class="pic"><img data-is-loaded="true" height="428" src="./images/29952-0040-0035.jpg" style="vertical-align: middle; width: 652px; height: 428px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="652"/><p class="imgtitle" style="text-align:center;">图1-23 方框滤波非归一化（Size（1,1））</p></div><p class="content" style="text-indent:2em;">此时的调用代码中，Size大小为Size（1,1）：</p><p class="content_108">boxFilter（srcImage,dstImage,-1,Size（1,1）,Point（-1,-1）,false）;</p><p class="content_102">3.高斯滤波</p><p class="content" style="text-indent:2em;">高斯滤波效果如图1-24所示。</p><div class="pic"><img data-is-loaded="true" height="388" src="./images/29952-0041-0036.jpg" style="vertical-align: middle; width: 589px; height: 388px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="589"/><p class="imgtitle" style="text-align:center;">图1-24 高斯滤波效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_GaussFilter_triggered（）</p><p class="content_104">{</p><p class="content_105">//高斯滤波</p><p class="content_105">//调用函数GaussianBlur</p><p class="content_105">GaussianBlur（ srcImage, dstImage, Size（ 7,7 ）, 0, 0 ）;</p><p class="content_105">//显示结果</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">4.中值滤波</p><p class="content" style="text-indent:2em;">中值滤波效果如图1-25所示。</p><div class="pic"><img data-is-loaded="true" height="395" src="./images/29952-0041-0037.jpg" style="vertical-align: middle; width: 599px; height: 395px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="599"/><p class="imgtitle" style="text-align:center;">图1-25 中值滤波效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_medianFilter_triggered（）</p><p class="content_104">{</p><p class="content_105">//中值滤波</p><p class="content_105">//调用函数medianBlur，参数采用默认值</p><p class="content_105">medianBlur （ srcImage, dstImage, 7 ）;</p><p class="content_105">//显示处理结果</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">5.双边滤波</p><p class="content" style="text-indent:2em;">双边滤波效果如图1-26所示。</p><div class="pic"><img data-is-loaded="true" height="432" src="./images/29952-0042-0038.jpg" style="vertical-align: middle; width: 658px; height: 432px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="658"/><p class="imgtitle" style="text-align:center;">图1-26 双边滤波效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_bilateralFilter_triggered（）</p><p class="content_104">{</p><p class="content_105">//双边滤波</p><p class="content_105">//调用bilateralFilter</p><p class="content_105">bilateralFilter （ srcImage, dstImage, 31, 31*2, 31/2 ）;</p><p class="content_105">//显示处理结果</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><h3 class="thirdTitle" id="bw15">1.3.5 缩放的实现</h3><p class="content" style="text-indent:2em;">缩放分别使用 pyrUp 函数、pyrDown 函数、resize 函数实现。该部分的菜单如图1-27所示。</p><div class="pic"><img data-is-loaded="true" height="222" src="./images/29952-0043-0039.jpg" style="vertical-align: middle; width: 430px; height: 222px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="430"/><p class="imgtitle" style="text-align:center;">图1-27 “缩放”菜单</p></div><p class="content_102">1.放大（PyrUp）</p><p class="content" style="text-indent:2em;">放大（PyrUp）效果如图1-28所示。</p><div class="pic"><img data-is-loaded="true" height="390" src="./images/29952-0043-0040.jpg" style="vertical-align: middle; width: 595px; height: 390px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="595"/><p class="imgtitle" style="text-align:center;">图1-28 放大（PyrUp）效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_PyrUpAction_triggered（）</p><p class="content_104">{</p><p class="content_105">//调用pyrUp实现放大效果</p><p class="content_108">pyrUp（ srcImage, dstImage, Size（ srcImage.cols*2, srcImage.rows*2 ））;</p><p class="content_108">//显示处理结果的局部</p><p class="content_108">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_108">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">2.缩小（PyrDown）</p><p class="content" style="text-indent:2em;">缩小（PyrDown）效果如图1-29所示。</p><div class="pic"><img data-is-loaded="true" height="373" src="./images/29952-0044-0041.jpg" style="vertical-align: middle; width: 565px; height: 373px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="565"/><p class="imgtitle" style="text-align:center;">图1-29 缩小（PyrDown）效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_PyrDownAction_triggered（）</p><p class="content_104">{</p><p class="content_105">//调用pyrDown实现缩小效果</p><p class="content_105">pyrDown（ srcImage, dstImage, Size（ srcImage.cols/2, srcImage.rows/2））;</p><p class="content_105">//显示处理结果的图像实际大小</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">说明：这里为了显示上的直观，将源图像放大处理后显示在主界面的标签内，目标图像的大小未做调整直接显示在标签内，因此目标图像与源图像的比例与程序中所确定的比例并不一致。本示例中源图像大小为128×128像素。后续的缩小示例处理方法与此相同。</p><p class="content_102">3.放大（Resize）</p><p class="content" style="text-indent:2em;">放大（Resize）效果如图1-30所示。</p><div class="pic"><img data-is-loaded="true" height="352" src="./images/29952-0044-0042.jpg" style="vertical-align: middle; width: 533px; height: 352px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="533"/><p class="imgtitle" style="text-align:center;">图1-30 放大（Resize）效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_ResizeUp_triggered（）</p><p class="content_104">{</p><p class="content_105">//调用resize放大图像</p><p class="content_105">cv::resize（srcImage,dstImage,Size（ srcImage.cols*4, srcImage.rows*4 ）,0,0,3）;</p><p class="content_105">//显示处理结果</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">4 缩小（Resize）</p><p class="content" style="text-indent:2em;">缩小（Resize）效果如图1-31所示。</p><div class="pic"><img data-is-loaded="true" height="339" src="./images/29952-0045-0043.jpg" style="vertical-align: middle; width: 512px; height: 339px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="512"/><p class="imgtitle" style="text-align:center;">图1-31 缩小（Resize）效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_ResizeDown_triggered（）</p><p class="content_104">{</p><p class="content_105">//调用resize缩小图像</p><p class="content_105">cv::resize（srcImage,dstImage,Size（ srcImage.cols/4, srcImage.rows/4 ）,0,0,3）;</p><p class="content_105">//显示结果图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><h3 class="thirdTitle" id="bw16">1.3.6 旋转的实现</h3><p class="content" style="text-indent:2em;">旋转分别实现了顺时针无缩放旋转、顺时针缩放旋转、逆时针旋转、零旋转缩放等。该部分的菜单如图1-32所示。</p><div class="pic"><img data-is-loaded="true" height="211" src="./images/29952-0046-0044.jpg" style="vertical-align: middle; width: 450px; height: 211px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="450"/><p class="imgtitle" style="text-align:center;">图1-32 “旋转”菜单</p></div><p class="content_102">1.顺时针无缩放</p><p class="content" style="text-indent:2em;">顺时针无缩放效果如图1-33所示。</p><div class="pic"><img data-is-loaded="true" height="327" src="./images/29952-0046-0045.jpg" style="vertical-align: middle; width: 493px; height: 327px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="493"/><p class="imgtitle" style="text-align:center;">图1-33 顺时针无缩放效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_cNresize_triggered（）</p><p class="content_104">{</p><p class="content_105">//顺时针无缩放效果</p><p class="content_105">//定义Point2f</p><p class="content_105">Point2f srcTri[3];</p><p class="content_105">Point2f dstTri[3];</p><p class="content_105">Mat rot_mat（ 2, 3, CV_32FC1 ）;</p><p class="content_105">Mat warp_mat（ 2, 3, CV_32FC1 ）;</p><p class="content_105">Mat src, warp_dst, warp_rotate_dst;</p><p class="content_105">//读入图像</p><p class="content_105">srcImage.copyTo（src）;</p><p class="content_105">warp_dst = Mat::zeros（ src.rows, src.cols, src.type（） ）;</p><p class="content_105">//用3个点确定A仿射变换</p><p class="content_105">Point center = Point（ src.cols/2,src.rows/2 ）;</p><p class="content_105">double angle = -50.0;</p><p class="content_105">double scale = 1;</p><p class="content_105">rot_mat = getRotationMatrix2D（ center, angle, scale ）;</p><p class="content_105">warpAffine（src, warp_rotate_dst, rot_mat, warp_dst.size（） ）;</p><p class="content_105">//OpenCV早期版本的形式</p><p class="content_105">//IplImage * img=cvLoadImage（"baboon.jpg"）;</p><p class="content_105">//IplImage *img_rotate=cvCloneImage（img）;</p><p class="content_105">//CvMat M =warp_mat;</p><p class="content_105">//cvWarpAffine（img,img_rotate,</p><p class="content_105">&amp;M,CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,cvScalarAll（0） ）;</p><p class="content_105">//cvShowImage（"Wrap2",img_rotate）;</p><p class="content_105">warp_rotate_dst.copyTo（dstImage）;</p><p class="content_105">//显示处理效果</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">2.顺时针缩放</p><p class="content" style="text-indent:2em;">顺时针缩放效果如图1-34所示。</p><div class="pic"><img data-is-loaded="true" height="422" src="./images/29952-0047-0046.jpg" style="vertical-align: middle; width: 641px; height: 422px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="641"/><p class="imgtitle" style="text-align:center;">图1-34 顺时针缩放效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_cResize_triggered（）</p><p class="content_104">{</p><p class="content_105">//顺时针缩放效果</p><p class="content_105">//定义Point2f</p><p class="content_105">Point2f srcTri[3];</p><p class="content_105">Point2f dstTri[3];</p><p class="content_105">Mat rot_mat（ 2, 3, CV_32FC1 ）;</p><p class="content_105">Mat warp_mat（ 2, 3, CV_32FC1 ）;</p><p class="content_105">Mat src, warp_dst, warp_rotate_dst;</p><p class="content_105">//读入图像</p><p class="content_105">srcImage.copyTo（src）;</p><p class="content_105">warp_dst = Mat::zeros（ src.rows, src.cols, src.type（） ）;</p><p class="content_105">//用3个点确定A仿射变换</p><p class="content_105">Point center = Point（ src.cols/2,src.rows/2 ）;</p><p class="content_105">double angle = -50.0;</p><p class="content_105">double scale = 0.6;</p><p class="content_105">rot_mat = getRotationMatrix2D（ center, angle, scale ）;</p><p class="content_105">warpAffine（src, warp_rotate_dst, rot_mat, warp_dst.size（） ）;</p><p class="content_105">// OpenCV早期版本的形式</p><p class="content_105">//IplImage * img=cvLoadImage（"baboon.jpg"）;</p><p class="content_105">//IplImage *img_rotate=cvCloneImage（img）;</p><p class="content_105">//CvMat M =warp_mat;</p><p class="content_105">//cvWarpAffine（img,img_rotate,</p><p class="content_105">&amp;M,CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,cvScalarAll（0） ）;</p><p class="content_105">//cvShowImage（"Wrap2",img_rotate）;</p><p class="content_105">warp_rotate_dst.copyTo（dstImage）;</p><p class="content_105">//显示处理效果</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）,QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">3.逆时针</p><p class="content" style="text-indent:2em;">逆时针效果如图1-35所示。</p><div class="pic"><img data-is-loaded="true" height="405" src="./images/29952-0048-0047.jpg" style="vertical-align: middle; width: 619px; height: 405px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="619"/><p class="imgtitle" style="text-align:center;">图1-35 逆时针效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_antiClockwise_triggered（）</p><p class="content_104">{</p><p class="content_105">//逆时针效果</p><p class="content_105">Point2f srcTri[3];</p><p class="content_105">Point2f dstTri[3];</p><p class="content_105">Mat rot_mat（ 2, 3, CV_32FC1 ）;</p><p class="content_105">Mat warp_mat（ 2, 3, CV_32FC1 ）;</p><p class="content_105">Mat src, warp_dst, warp_rotate_dst;</p><p class="content_105">//读入图像</p><p class="content_105">srcImage.copyTo（src）;</p><p class="content_105">warp_dst = Mat::zeros（ src.rows, src.cols, src.type（） ）;</p><p class="content_105">//用3个点确定A仿射变换</p><p class="content_105">Point center = Point（ src.cols/2,src.rows/2 ）;</p><p class="content_105">double angle = 50.0;</p><p class="content_105">double scale = 0.6;</p><p class="content_105">rot_mat = getRotationMatrix2D（ center, angle, scale ）;</p><p class="content_105">warpAffine（src, warp_rotate_dst, rot_mat, warp_dst.size（） ）;</p><p class="content_105">//OpenCV早期版本的形式</p><p class="content_105">//IplImage * img=cvLoadImage（"baboon.jpg"）;</p><p class="content_105">//IplImage *img_rotate=cvCloneImage（img）;</p><p class="content_105">//CvMat M =warp_mat;</p><p class="content_105">//cvWarpAffine（img,img_rotate,</p><p class="content_108">&amp;M,CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,cvScalarAll（0） ）;</p><p class="content_105">//cvShowImage（"Wrap2",img_rotate）;</p><p class="content_105">warp_rotate_dst.copyTo（dstImage）;</p><p class="content_105">//显示处理效果</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">4.零旋转缩放</p><p class="content" style="text-indent:2em;">零旋转缩放实现没有旋转的缩放效果，其具体的实现效果如图1-36所示。</p><div class="pic"><img data-is-loaded="true" height="418" src="./images/29952-0049-0048.jpg" style="vertical-align: middle; width: 638px; height: 418px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="638"/><p class="imgtitle" style="text-align:center;">图1-36 零旋转缩放效果</p></div><p class="content" style="text-indent:2em;">其实现的具体代码为：</p><p class="content_104">void MainWindow::on_NFlipResize_triggered（）</p><p class="content_104">{</p><p class="content_105">//零旋转缩放效果</p><p class="content_105">Point2f srcTri[3];</p><p class="content_105">Point2f dstTri[3];</p><p class="content_105">Mat rot_mat（ 2, 3, CV_32FC1 ）;</p><p class="content_105">Mat warp_mat（ 2, 3, CV_32FC1 ）;</p><p class="content_105">Mat src, warp_dst, warp_rotate_dst;</p><p class="content_105">//读入图像</p><p class="content_105">srcImage.copyTo（src）;</p><p class="content_105">warp_dst = Mat::zeros（ src.rows, src.cols, src.type（） ）;</p><p class="content_105">//用3个点确定A仿射变换</p><p class="content_105">Point center = Point（ src.cols/2,src.rows/2 ）;</p><p class="content_105">double angle = 0;</p><p class="content_105">double scale = 0.6;</p><p class="content_105">rot_mat = getRotationMatrix2D（ center, angle, scale ）;</p><p class="content_105">warpAffine（src, warp_rotate_dst, rot_mat, warp_dst.size（） ）;</p><p class="content_105">// OpenCV早期版本的形式</p><p class="content_105">//IplImage * img=cvLoadImage（"baboon.jpg"）;</p><p class="content_105">//IplImage *img_rotate=cvCloneImage（img）;</p><p class="content_105">//CvMat M =warp_mat;</p><p class="content_105">//cvWarpAffine（img,img_rotate,</p><p class="content_105">&amp;M,CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,cvScalarAll（0） ）;</p><p class="content_105">//cvShowImage（"Wrap2",img_rotate）;</p><p class="content_105">warp_rotate_dst.copyTo（dstImage）;</p><p class="content_105">//显示处理效果</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols* dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><h3 class="thirdTitle" id="bw17">1.3.7 帮助</h3><p class="content" style="text-indent:2em;">本部分的菜单主要包含版权、关于等信息，更详细的设计信息请参考附录 B部分。其部分示例如图1-37所示。</p><div class="pic"><img data-is-loaded="true" height="166" src="./images/29952-0050-0049.jpg" style="vertical-align: middle; width: 678px; height: 166px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="678"/><p class="imgtitle" style="text-align:center;">图1-37 帮助示例</p></div></div><div class="section_box" data-v-4f9376c5="" id="section_5" style="min-height: 674px; background-color: rgb(255, 255, 255); font-size: 16px;"><h1 class="firstTitle">第2章 医学图像处理算法学习系统</h1><p class="content" style="text-indent:2em;">随着信息技术的不断发展，医学影像成像技术、处理技术取得了很大的进步，医学图像处理在医学临床、教学、科研中都发挥着非常重要的作用。医学图像处理技术的发展有力地推动了医学科学研究的进步发展和临床医疗水平的提升。同时，医学图像处理技术的提升极大地降低了人类的痛苦，为人类带来了极大的福祉。</p><p class="content" style="text-indent:2em;">本章主要实现了在医学图像处理过程中经常需要使用的图像处理方法，具体包括：增强、卷积、模板匹配、仿射变换、重映射、分割等。</p><h2 class="secondTitle" id="bw18">2.1 系统介绍</h2><p class="content" style="text-indent:2em;">本系统采用OpenCV 3.0在Qt Creator内开发，为了让读者能够更好地掌握OpenCV 3.0的函数并了解Qt开发的基本原理，本系统在实现的过程中，尽量将每一个处理作为一个独立单元实现。</p><h3 class="thirdTitle" id="bw19">2.1.1 功能描述</h3><p class="content" style="text-indent:2em;">本系统实现了医学数字图像处理中常用的增强、卷积、模板匹配、仿射变换、重映射、分割等功能。系统内各个功能的实现均采用了OpenCV 3.0的函数实现。</p><p class="content" style="text-indent:2em;">在增强的实现中，采用了直方图均衡化、亮度调节、对比度调节、亮度对比度同时调节等多种方式。在卷积处理中，通过调整参数值实现了多种不同的处理效果。在模板匹配过程中，实现了多种不同形式的模板匹配方法，分别使用cv::TM_SQDIFF、cv::TM_SQDIFF_NORMED、cv::TM_CCORR、cv::TM_CCORR_NORMED、cv::TM_CCOEFF、cv::TM_CCOEFF_NORMED 等多种方法对模板匹配进行了实现。在仿射变换中，分别实现了单纯仿射和旋转仿射。在重映射的实现中，分别实现了复制方式的重映射、x轴方向重映射、y轴方向重映射、缩小重映射、旋转重映射、x与y轴互换重映射等多种方式的重映射。在分割的实现中，分别对threshold函数、adaptiveThreshold函数的参数进行调整，从而实现了多种不同的分割效果。</p><h3 class="thirdTitle" id="bw20">2.1.2 系统结构</h3><p class="content" style="text-indent:2em;">系统的总体结构如图2-1所示。</p><div class="pic"><img data-is-loaded="true" height="240" src="./images/29952-0052-0050.jpg" style="vertical-align: middle; width: 700px; height: 240px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/><p class="imgtitle" style="text-align:center;">图2-1 系统的总体结构</p></div><h3 class="thirdTitle" id="bw21">2.1.3 界面效果</h3><p class="content" style="text-indent:2em;">系统界面如图2-2所示。</p><div class="pic"><img data-is-loaded="true" height="407" src="./images/29952-0053-0051.jpg" style="vertical-align: middle; width: 593px; height: 407px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="593"/><p class="imgtitle" style="text-align:center;">图2-2 系统界面</p></div><h2 class="secondTitle" id="bw22">2.2 系统原理</h2><p class="content" style="text-indent:2em;">本部分重点介绍系统各个功能实现的基本原理，并对各个功能所使用函数的语法格式做一个具体的说明。</p><h3 class="thirdTitle" id="bw23">2.2.1 增强</h3><p class="content" style="text-indent:2em;">增强主要考虑通过直方图均衡化、对比度、亮度、亮度对比度等几种方式实现，具体实现方式介绍如下。</p><p class="content_102">1.直方图均衡化</p><p class="content" style="text-indent:2em;">当一幅图像内的像素值占所有的灰度级并且分布均匀，则该图像具有较高的对比度和多变的色调变化，此时图像看起来层次明显、细节清晰。直方图均衡化的目的是将一幅图像中的像素值进行映射变换，使得映射结果图像的灰度分布均衡，此时图像对比度增加，视觉上感到更加清晰。</p><p class="content" style="text-indent:2em;">在OpenCV 3.0内采用函数equalizeHist实现直方图均衡化，其语法格式如下：</p><p class="content_104">void cv::equalizeHist（</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：原始图像，8位单通道。</p><p class="content" style="text-indent:2em;">●dst：目标图像，与原始图像具有同样的格式和大小。</p><p class="content" style="text-indent:2em;">上述函数的算法可以描述为：</p><p class="content" style="text-indent:2em;">（1）计算原始图像src的灰度直方图H。</p><p class="content" style="text-indent:2em;">（2）对直方图H进行归一化处理，确保在0～255之间均匀分布。</p><p class="content" style="text-indent:2em;">（3）计算直方图积分</p><div class="bodyPic_107"><img data-is-loaded="true" height="81" src="./images/29952-0054-0052.jpg" style="vertical-align: middle; width: 213px; height: 81px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="213"/></div><p class="content" style="text-indent:2em;">根据上述公式查找原始像素点的计算结果，dst（x,y）=H＇（src（x,y））。</p><p class="content_102">2.亮度和对比度</p><p class="content" style="text-indent:2em;">OpenCV 3.0内的convertTo函数能够实现图像格式的转换。在该函数的参数中，有能够改变其对比度和亮度的参数，因此，可以使用该函数来完成亮度和对比度的调整。该函数的具体语法格式如下：</p><p class="content_104">void cv::Mat::convertTo（</p><p class="content_105">OutputArray m,</p><p class="content_105">int rtype,</p><p class="content_105">double alpha = 1,</p><p class="content_105">double beta = 0 ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●m：输出图像。如果大小或者类型不匹配，该图像将被重新分配大小类型。</p><p class="content" style="text-indent:2em;">●rtype：输出矩阵的类型。如果该值为负数，则输出图像具有和原始图像相同的类型。</p><p class="content" style="text-indent:2em;">●alpha：对比度调节参数，可选项。</p><p class="content" style="text-indent:2em;">●beta：亮度调节参数，可选项。</p><p class="content" style="text-indent:2em;">上述函数的算法可以描述为：</p><p class="content_100">dst=alpha × src+beta</p><p class="content" style="text-indent:2em;">经过上述运算后，可能会出现元素溢出，为了避免元素溢出，系统会自动采用saturate_cast对溢出做处理，其语法格式为：</p><p class="content_104">static _Tp cv::saturate_cast （数据类型）</p><p class="content" style="text-indent:2em;">该函数具有多个重载函数，其中的数据类型可以是多种类型的数据。例如可以是uchar、short、int、double等不同的类型。</p><p class="content" style="text-indent:2em;">当其中的参数存在溢出时，如果是上溢出，则取其类型内的最大值作为处理结果；如果是下溢出，则取其类型内的最小值作为处理结果。例如：</p><p class="content_104">uchar a = saturate_cast＜uchar＞（-100）; // a = 0 （UCHAR_MIN）</p><p class="content_104">short b = saturate_cast＜short＞（33333.33333）; // b = 32767 （SHRT_MAX）</p><p class="content" style="text-indent:2em;">由于是自动调用该函数，因此在进行亮度和对比度的处理时，相当于进行运算：</p><p class="content_100">dst=saturate_cast＜rType＞（alpha × src+beta）</p><h3 class="thirdTitle" id="bw24">2.2.2 卷积</h3><p class="content" style="text-indent:2em;">卷积（Convolves）是指对图像的每一个部分都进行操作。针对图像的操作，均可看成是卷积的特殊情况。这里的卷积指使用OpenCV 3.0的filter2D函数进行卷积运算，函数的语法格式如下：</p><p class="content_104">void cv::filter2D （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">int ddepth,</p><p class="content_105">InputArray kernel,</p><p class="content_105">Point anchor = Point（-1,-1）,</p><p class="content_105">double delta = 0,</p><p class="content_105">int borderType = BORDER_DEFAULT ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：要操作的图像。</p><p class="content" style="text-indent:2em;">●dst：输出图像，和原始图像src具有同样的大小和通道数。</p><p class="content" style="text-indent:2em;">●ddepth：目标图像的深度。通常采用src.depth（）即可。如果自定义，该值不能低于原始图像，其关系可以如表2-1所示。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表2-1 ddepth关系</p><img data-is-loaded="true" height="170" src="./images/29952-0055-0053.jpg" style="vertical-align: middle; width: 700px; height: 170px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><p class="content" style="text-indent:2em;">当ddepth=-1时，输出图像和原始图像具有同样的深度。</p><p class="content" style="text-indent:2em;">●kernel：卷积核。该值通常是一个单通道的浮点型矩阵。如果想对一个多通道图像应用不同的核，则需要先将多通道图像分离成不同的通道，单独进行卷积运算后，再将运算结果进行合并。</p><p class="content" style="text-indent:2em;">●anchor：锚点位置。指出锚点在核中所在的位置，锚点必须在核内。默认值是（-1,-1），表示位于核的中心点位置。</p><p class="content" style="text-indent:2em;">●delta：亮度调节值。卷积运算结束后，将该值加到目标图像内。该值是可选项。</p><p class="content" style="text-indent:2em;">●borderType：边界类型。其可选值的具体值如表2-2所示。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表2-2 borderType值</p><img data-is-loaded="true" height="239" src="./images/29952-0055-0054.jpg" style="vertical-align: middle; width: 700px; height: 239px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><div class="pic_106"><p class="imgtitle_109">续表</p><img data-is-loaded="true" height="143" src="./images/29952-0056-0055.jpg" style="vertical-align: middle; width: 700px; height: 143px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><h3 class="thirdTitle" id="bw25">2.2.3 模板匹配</h3><p class="content" style="text-indent:2em;">模板匹配是在当前图像A内寻找与图像B最为相似的部分，图像A一般被称为输入图像，图像B一般被称为模板图像。模板匹配的方式是将模板图像B通过滑动的方式在图像A上遍历以完成匹配。</p><p class="content" style="text-indent:2em;">在OpenCV 3.0内，模板匹配的函数为matchTemplate，该函数的语法格式为：</p><p class="content_104">void cv::matchTemplate（</p><p class="content_105">InputArray image,</p><p class="content_105">InputArray templ,</p><p class="content_105">OutputArray result,</p><p class="content_105">int method,</p><p class="content_105">InputArray mask = noArray（） ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●image：原始图像，必须是8位或者32位的浮点型图像。</p><p class="content" style="text-indent:2em;">●templ：要寻找的模板图像。它的尺寸必须要小于等于原始图像，并且与原始图像具有同样的类型。</p><p class="content" style="text-indent:2em;">●result：比较结果的映射图像，必须是单通道 32 位浮点型。如果原始图像尺寸是W×H，模板图像是w×h，则该参数的值为（W-w+1）×（H-h+1）。</p><p class="content" style="text-indent:2em;">●method：匹配方法。该参数通过 cv::TemplateMatchModes 实现，其可能有6种值，如表2-3所示。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表2-3 method的可能值</p><img data-is-loaded="true" height="302" src="./images/29952-0056-0056.jpg" style="vertical-align: middle; width: 700px; height: 302px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><p class="content" style="text-indent:2em;">其具体对应的公式关系如表2-4所示。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表2-4 method值具体对应的公式关系</p><img data-is-loaded="true" height="502" src="./images/29952-0057-0057.jpg" style="vertical-align: middle; width: 700px; height: 502px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><p class="content" style="text-indent:2em;">●mask：查找模板掩码。它必须和查找模板具有相同的类型和大小。</p><p class="content" style="text-indent:2em;">由于采用的查找方法不同（method值不同），结果的判定方式也不同，结果果判定使用minMaxLoc函数实现，该函数语法格式如下：</p><p class="content_104">void cv::minMaxLoc（</p><p class="content_105">InputArray src,</p><p class="content_105">double * minVal,</p><p class="content_105">double * maxVal = 0,</p><p class="content_105">Point * minLoc = 0,</p><p class="content_105">Point * maxLoc = 0,</p><p class="content_105">InputArray mask = noArray（） ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：单通道数组。</p><p class="content" style="text-indent:2em;">●minVal：返回最小值的指针，如果没有可以是NULL。</p><p class="content" style="text-indent:2em;">●maxVal：返回最大值的指针，如果没有可以是NULL。</p><p class="content" style="text-indent:2em;">●minLoc：最小值的位置指针，如果没有可以是NULL。</p><p class="content" style="text-indent:2em;">●maxLoc：最大值的位置指针，如果没有可以是NULL。</p><p class="content" style="text-indent:2em;">●mask：用来选取掩码的子集，可选项。</p><p class="content" style="text-indent:2em;">该函数能够找到最大值、最小值及其位置。该函数能够查找整个数组内的极值，并可以根据当前的掩码集来选取特定子集的极值。该函数仅仅能够作用于单通道数组，如果想得到多通道的数组极值，需要使用 Mat::reshape 将当前数据集转换为单通道。也能够使用extractImageCOI、mixChannels或split提取特定的通道。</p><p class="content" style="text-indent:2em;">OpenCV 3.0内提供了重载函数，该重载函数与上述函数的不同之处仅仅在于参数的类型不同，其具体语法格式如下：</p><p class="content_104">void cv::minMaxLoc （</p><p class="content_105">const SparseMat &amp; a,</p><p class="content_105">double * minVal,</p><p class="content_105">double * maxVal,</p><p class="content_105">int * minIdx = 0,</p><p class="content_105">int * maxIdx = 0 ）</p><h3 class="thirdTitle" id="bw26">2.2.4 仿射变换</h3><p class="content" style="text-indent:2em;">仿射变换是指图像可以通过一系列的几何变换来实现包括平移、缩放、翻转、旋转和错切等多种操作。该变换能够保持图像的平直性和平行性。平直性是指图像经过放射后，直线仍旧是直线；平行性是指图像在完成变换后，平行线仍旧是平行线。</p><p class="content" style="text-indent:2em;">在OpenCV 3.0内仿射函数为warpAffine，其通过一个InputArray的M实现变换，具体为：</p><p class="content_100">dst（x,y）=src（M<span class="sub">11</span>x+M<span class="sub">12</span>y+M<span class="sub">13</span>,M<span class="sub">21</span>x+M<span class="sub">22</span>y+M<span class="sub">23</span>）</p><p class="content" style="text-indent:2em;">如图2-3所示，可以通过一个变换矩阵，将图2-3（a）变换到图2-3（b）。</p><div class="pic"><img data-is-loaded="true" height="293" src="./images/29952-0058-0058.jpg" style="vertical-align: middle; width: 512px; height: 293px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="512"/><p class="imgtitle" style="text-align:center;">图2-3 仿射变换</p></div><p class="content" style="text-indent:2em;">函数warpAffine的语法格式如下：</p><p class="content_104">void cv::warpAffine （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">InputArray M,</p><p class="content_105">Size dsize,</p><p class="content_105">int flags = INTER_LINEAR,</p><p class="content_105">int borderMode = BORDER_CONSTANT,</p><p class="content_105">const Scalar &amp; borderValue = Scalar（） ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：原始图像。</p><p class="content" style="text-indent:2em;">●dst：具有和原始图像同样类型，dsize大小的输出图像。</p><p class="content" style="text-indent:2em;">●M：2×3的变换矩阵。</p><p class="content" style="text-indent:2em;">●dsize：输出图像的大小。</p><p class="content" style="text-indent:2em;">●flags：插值方法。如果是 WARP_INVERSE_MAP，则表示该操作是可逆的。其方法如表2-5所示。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表2-5 flags的可能值</p><img data-is-loaded="true" height="388" src="./images/29952-0059-0059.jpg" style="vertical-align: middle; width: 700px; height: 388px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><p class="content" style="text-indent:2em;">●borderMode：边界模式，当该值为BORDER_TRANSPARENT时，意味着目标图像与原始图像的奇异点（outliers，或离群点）对应的点不做调整。该值的可选项可以参考表2-2。</p><p class="content" style="text-indent:2em;">●borderValue：边界值，默认是0。</p><h3 class="thirdTitle" id="bw27">2.2.5 重映射</h3><p class="content" style="text-indent:2em;">把一幅图像内的像素点放置到另外一幅图像内的指定位置，称为重映射。图像的旋转、缩放、翻转等都是重映射。OpenCV 3.0提供了专门的重映射函数remap，其所表示的变换为：</p><p class="content_100">dst（x,y）=src（map<span class="sub">x</span>（x,y）,map<span class="sub">y</span>（x,y））</p><p class="content" style="text-indent:2em;">函数remap的语法格式如下：</p><p class="content_104">void cv::remap （</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">InputArray map1,</p><p class="content_105">InputArray map2,</p><p class="content_105">int interpolation,</p><p class="content_105">int borderMode = BORDER_CONSTANT,</p><p class="content_105">const Scalar &amp; borderValue = Scalar（） ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：原始图像。</p><p class="content" style="text-indent:2em;">●dst：目标图像，它和map1具有同样的大小，和src具有相同的类型。</p><p class="content" style="text-indent:2em;">●map1：该参数有两种可能的值如下。</p><p class="content" style="text-indent:2em;">- 表示（x,y）点的一个映射。</p><p class="content" style="text-indent:2em;">- 表示CV_16SC2、CV_32FC1、CV_32FC2类型的x值。</p><p class="content" style="text-indent:2em;">●map2：该参数同样有两种可能的值如下。</p><p class="content" style="text-indent:2em;">- 在map1表示（x,y）时，该值为空。</p><p class="content" style="text-indent:2em;">- 在map1表示x值时，该值是CV_16UC1、CV_32FC1类型的y值。</p><p class="content" style="text-indent:2em;">●interpolation：插值方式，这里不支持INTER_AREA方法。具体值如表2-5所示。</p><p class="content" style="text-indent:2em;">●borderMode：边界模式。当该值为BORDER_TRANSPARENT时，表示目标图像内的对应于源图像内奇异点（outliers）的像素不会被修改。</p><p class="content" style="text-indent:2em;">●borderValue：边界值，该值默认为0。</p><h3 class="thirdTitle" id="bw28">2.2.6 分割</h3><p class="content" style="text-indent:2em;">阈值分割是图像分割过程中常用的一种方法，它利用图像中像素点像素值的大小差异，通过设置阈值的方式将图像中的像素点进行分类，从而达到图像分割的目的。</p><p class="content" style="text-indent:2em;">在实际使用中，通常将图像中的像素点划分为前景色和背景色，即将彩色图像或灰度图像转换为二值图像。例如，在一幅图像中，可以将128设置为阈值，则像素值大于128的像素点可以划分为前景色，像素值小于等于128的像素点可以划分为背景色。</p><p class="content" style="text-indent:2em;">具体可以表示为：</p><div class="bodyPic_107"><img data-is-loaded="true" height="83" src="./images/29952-0060-0060.jpg" style="vertical-align: middle; width: 302px; height: 83px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="302"/></div><p class="content" style="text-indent:2em;">其中，src是原图像，result是分割后图像，T是设定的阈值，i和j是像素的坐标位置。</p><p class="content" style="text-indent:2em;">在OpenCV 3.0中，阈值分割通过函数threshold（）和函数adaptiveThreshold（）实现。函数threshold（）是基本阈值分割，函数adaptiveThreshold（）是自适应阈值分割。</p><p class="content_102">1.基本阈值分割</p><p class="content" style="text-indent:2em;">基本阈值分割需要自定义阈值，通过函数 threshold（）实现，其具体语法格式为：</p><p class="content_104">double cv::threshold（</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">double thresh,</p><p class="content_105">double maxval,</p><p class="content_105">int type ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：要进行阈值分割的图像，必须是单通道的，8位或32位的浮点型。</p><p class="content" style="text-indent:2em;">●dst：阈值分割结果图像，与原始图像具有相同的大小和类型。</p><p class="content" style="text-indent:2em;">●thresh：设定的阈值。</p><p class="content" style="text-indent:2em;">●maxval：当type参数（该函数最多有一个参数）为THRESH_BINARY或者THRESH_BINARY_INV类型时，需要设定的最大值。</p><p class="content" style="text-indent:2em;">●type：阈值分割的类型，具体类型值如表2-6所示。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表2-6 阈值分割类型</p><img data-is-loaded="true" height="396" src="./images/29952-0061-0061.jpg" style="vertical-align: middle; width: 700px; height: 396px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><p class="content" style="text-indent:2em;">上述公式相对抽象，可以将其可视化，具体如图 2-4 所示（该图像来源于OpenCV官方网站，略做修改）。</p><div class="pic"><img data-is-loaded="true" height="542" src="./images/29952-0061-0062.jpg" style="vertical-align: middle; width: 429px; height: 542px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="429"/><p class="imgtitle" style="text-align:center;">图2-4 阈值类型可视化</p></div><p class="content" style="text-indent:2em;">其中THRESH_OTSU、THRESH_TRIANGLE通常与其他类型的值组合使用，此时函数会使用Otsu算法或Triangle算法计算最优阈值，并用该最优阈值代替固定阈值。目前，Otsu 算法或 Triangle 算法仅仅对 8位的位图有效。</p><p class="content_102">2.自适应阈值分割</p><p class="content" style="text-indent:2em;">自适应阈值分割函数为adaptiveThreshold（），其具体语法格式为：</p><p class="content_104">void cv::adaptiveThreshold（</p><p class="content_105">InputArray src,</p><p class="content_105">OutputArray dst,</p><p class="content_105">double maxValue,</p><p class="content_105">int adaptiveMethod,</p><p class="content_105">int thresholdType,</p><p class="content_105">int blockSize,</p><p class="content_105">double C ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src：原始图像，需要8位单通道图像。</p><p class="content" style="text-indent:2em;">●dst：目标图像，具有和原始图像同样的大小和类型。</p><p class="content" style="text-indent:2em;">●maxValue：满足条件的非0值。</p><p class="content" style="text-indent:2em;">●adaptiveMethod：自适应阈值分割方法，具体方法如表2-7所示。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表2-7 自适应阈值分割方法</p><img data-is-loaded="true" height="204" src="./images/29952-0062-0063.jpg" style="vertical-align: middle; width: 700px; height: 204px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><p class="content" style="text-indent:2em;">●thresholdType：阈值类型，该值只能为THRESH_BINARY或THRESH_BINARY_INV二者之一。其具体形式为：</p><p class="content" style="text-indent:2em;">- THRESH_BINARY</p><div class="bodyPic_107"><img data-is-loaded="true" height="87" src="./images/29952-0062-0064.jpg" style="vertical-align: middle; width: 489px; height: 87px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="489"/></div><p class="content" style="text-indent:2em;">- THRESH_BINARY_INV</p><div class="bodyPic_107"><img data-is-loaded="true" height="85" src="./images/29952-0062-0065.jpg" style="vertical-align: middle; width: 477px; height: 85px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="477"/></div><p class="content" style="text-indent:2em;">式中，T（x,y）是每个像素经过计算后所得到的独立阈值。</p><p class="content" style="text-indent:2em;">●blockSize：计算当前像素点的阈值时所要使用的邻域大小范围，通常为奇数3、5、7等。</p><p class="content" style="text-indent:2em;">●C：常数，用它来与平均值或加权平均值相减。一般情况下，该值为正值。当然，该值也可能是0或者负值。</p><p class="content" style="text-indent:2em;">分割方法ADAPTIVE_THRESH_GAUSSIAN_C中，需要使用函数getGaussian Kernel，该函数的语法格式为：</p><p class="content_104">Mat cv::getGaussianKernel（</p><p class="content_105">int ksize,</p><p class="content_105">double sigma,</p><p class="content_105">int ktype = CV_64F ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●ksize：核大小，必须是奇数。</p><p class="content" style="text-indent:2em;">●sigma：高斯标准差。如果它是非正数，通过ksize计算得到</p><p class="content_100">sigma = 0.3×（（ksize-1）×0.5 - 1） + 0.8</p><p class="content" style="text-indent:2em;">●ktype：滤波器系数。它必须是CV_32F或者CV_64F。</p><p class="content_102">3.compare函数</p><p class="content" style="text-indent:2em;">函数threshold实现将灰度图像转换为二值图像，与此类似的函数是compare， compare函数能够执行两个数组或者一个数组和一个标量的运算。其语法格式为：</p><p class="content_104">void cv::compare（</p><p class="content_105">InputArray src1,</p><p class="content_105">InputArray src2,</p><p class="content_105">OutputArray dst,</p><p class="content_105">int cmpop ）</p><p class="content" style="text-indent:2em;">其中，</p><p class="content" style="text-indent:2em;">●src1：输入数组或标量，当它是数组时，必须是单通道的。</p><p class="content" style="text-indent:2em;">●src2：第2个输入数组或标量，当它是数组时，必须是单通道的。</p><p class="content" style="text-indent:2em;">●dst：输出数组，必须和输入数组具有同样的大小和通道数。</p><p class="content" style="text-indent:2em;">●cmpop：标志，表示数组之间的对应关系。具体值如表2-8所示。</p><div class="pic_106"><p class="imgtitle" style="text-align:center;">表2-8 cmpop类型</p><img data-is-loaded="true" height="240" src="./images/29952-0063-0066.jpg" style="vertical-align: middle; width: 700px; height: 240px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/></div><p class="content" style="text-indent:2em;">在进行运算时，</p><p class="content" style="text-indent:2em;">●当src1和src2具有同样大小时：</p><p class="content_100">dst（I）=src1（I） cmpop src2（I）</p><p class="content" style="text-indent:2em;">●当src2是由标量或者单个元素所组成时，将src1中的元素依次与src2进行运算：</p><p class="content_100">dst（I）=src1（I） cmpop src2</p><p class="content" style="text-indent:2em;">●当src1是由标量或者单个元素组成时，将src2中的元素依次与src1进行运算：</p><p class="content_100">dst（I）=src1 cmpop src2（I）</p><p class="content" style="text-indent:2em;">如果运算结果是真，则输出值被设置为255。</p><p class="content" style="text-indent:2em;">该函数可以直接表示为：</p><p class="content" style="text-indent:2em;">Mat dst1=src1＞=src2;</p><p class="content" style="text-indent:2em;">Mat dst2=src1＜8;</p><h2 class="secondTitle" id="bw29">2.3 编程实现</h2><p class="content" style="text-indent:2em;">该部分介绍各个功能的具体实现细节。</p><h3 class="thirdTitle" id="bw30">2.3.1 文件</h3><p class="content" style="text-indent:2em;">该部分的菜单如图 2-5 所示，该部分主要实现与源图像有关的图像输入、显示和文件关闭等功能。由于各章都涉及该部分的内容，因此将该部分的介绍放到了附录B内，有关该部分的具体实现细节信息请参考附录B部分，这里不再赘述。</p><div class="pic"><img data-is-loaded="true" height="278" src="./images/29952-0064-0067.jpg" style="vertical-align: middle; width: 526px; height: 278px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="526"/><p class="imgtitle" style="text-align:center;">图2-5 “文件”菜单</p></div><p class="content" style="text-indent:2em;">注意，为了节省篇幅和方便问题的说明，源文件的打开均在“文件”菜单内实现，后续操作都默认针对已经在“文件”菜单内打开了的源文件进行。</p><h3 class="thirdTitle" id="bw31">2.3.2 增强的实现</h3><p class="content" style="text-indent:2em;">增强的实现主要包括直方图均衡化、对比度调节、亮度调节、亮度对比度调节等功能。该部分的菜单如图2-6所示。</p><div class="pic"><img data-is-loaded="true" height="190" src="./images/29952-0065-0068.jpg" style="vertical-align: middle; width: 408px; height: 190px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="408"/><p class="imgtitle" style="text-align:center;">图2-6 “增强”菜单</p></div><p class="content_102">1.直方图均衡化</p><p class="content" style="text-indent:2em;">直方图均衡化需要首先进行通道的分解，然后对分解后得到的各个通道依次进行直方图均衡化处理，最后将处理后的各个通道再进行组合得到最终处理结果。该部分的实现效果如图2-7所示。</p><div class="pic"><img data-is-loaded="true" height="437" src="./images/29952-0065-0069.jpg" style="vertical-align: middle; width: 604px; height: 437px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="604"/><p class="imgtitle" style="text-align:center;">图2-7 直方图均衡化效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_HistEqualize_triggered（）</p><p class="content_104">{</p><p class="content_105">//直方图均衡化</p><p class="content_105">//定义一个数组，用来存储各通道图片的向量</p><p class="content_105">vector＜Mat＞ splitBGR（srcImage.channels（））;</p><p class="content_105">//分割通道，存储到splitBGR中</p><p class="content_105">split（srcImage,splitBGR）;</p><p class="content_105">//对各个通道分别进行直方图均衡化</p><p class="content_105">for（int i=0; i＜srcImage.channels（）; i++）</p><p class="content_108">equalizeHist（splitBGR[i],splitBGR[i]）;</p><p class="content_105">Mat mergeImg;//合并后的图像</p><p class="content_105">//合并通道</p><p class="content_105">merge（splitBGR,mergeImg）;</p><p class="content_105">//复制图像</p><p class="content_105">mergeImg.copyTo（dstImage）;</p><p class="content_105">// cv::cvtColor（dstImage,dstImage,CV_BGR2RGB）;</p><p class="content_105">//打开文件时已经完成BRG到RGB的转换</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）,QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">2.对比度</p><p class="content" style="text-indent:2em;">对比度调节，仅仅调整convertTo函数内参数alpha的值，参数beta默认为0。该部分的实现效果如图2-8所示。</p><div class="pic"><img data-is-loaded="true" height="426" src="./images/29952-0066-0070.jpg" style="vertical-align: middle; width: 589px; height: 426px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="589"/><p class="imgtitle" style="text-align:center;">图2-8 对比度调节效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_contrast_triggered（）</p><p class="content_104">{</p><p class="content_105">//调节对比度</p><p class="content_105">//这里仅仅调整alpha的值，beta默认为0</p><p class="content_105">srcImage.convertTo（dstImage,-1,2）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）,QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui -＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">3.亮度</p><p class="content" style="text-indent:2em;">亮度调节仅仅需要在convertTo函数内调整参数beta的值，参数alpha的值保持不变，因此将参数alpha的值设置为1。该部分的实现效果如图2-9所示。</p><div class="pic"><img data-is-loaded="true" height="376" src="./images/29952-0067-0071.jpg" style="vertical-align: middle; width: 521px; height: 376px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="521"/><p class="imgtitle" style="text-align:center;">图2-9 亮度调节效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_light_triggered（）</p><p class="content_104">{</p><p class="content_105">//调节亮度</p><p class="content_105">//这里仅仅调整beta的值，alpha设置为1</p><p class="content_105">srcImage.convertTo（dstImage,-1,1,80）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">4.亮度对比度</p><p class="content" style="text-indent:2em;">亮度对比度调节同时调节亮度和对比度，因此需要同时调整convertTo函数内参数alpha和参数beta的值。该部分的实现效果如图2-10所示。</p><div class="pic"><img data-is-loaded="true" height="388" src="./images/29952-0067-0072.jpg" style="vertical-align: middle; width: 535px; height: 388px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="535"/><p class="imgtitle" style="text-align:center;">图2-10 亮度对比度调节效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_contrastAndLight_triggered（）</p><p class="content_104">{</p><p class="content_105">//同时调节亮度、对比度</p><p class="content_105">//同时调整参数alpha、beta</p><p class="content_105">srcImage.convertTo（dstImage,-1,2,80）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><h3 class="thirdTitle" id="bw32">2.3.3 卷积的实现</h3><p class="content" style="text-indent:2em;">卷积处理采用了不同的核，分别实现了6种不同的处理效果，该部分的菜单如图2-11所示。</p><div class="pic"><img data-is-loaded="true" height="261" src="./images/29952-0068-0073.jpg" style="vertical-align: middle; width: 425px; height: 261px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="425"/><p class="imgtitle" style="text-align:center;">图2-11 “卷积”菜单</p></div><p class="content_102">1.算子1</p><p class="content" style="text-indent:2em;">该部分的实现效果如图2-12所示。</p><div class="pic"><img data-is-loaded="true" height="403" src="./images/29952-0068-0074.jpg" style="vertical-align: middle; width: 556px; height: 403px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="556"/><p class="imgtitle" style="text-align:center;">图2-12 算子1实现效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_filter2D1_triggered（）</p><p class="content_104">{</p><p class="content_105">//算子1</p><p class="content_105">//建立核</p><p class="content_105">Mat kernel = （Mat_＜float＞（3, 3） ＜＜ 0, -1, 0, -1, 5, -1, 0, -1, 0）;</p><p class="content_105">//应用函数filter2D处理</p><p class="content_105">filter2D（srcImage,dstImage, srcImage.depth（）, kernel）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">2.算子2</p><p class="content" style="text-indent:2em;">该部分的实现效果如图2-13所示。</p><div class="pic"><img data-is-loaded="true" height="418" src="./images/29952-0069-0075.jpg" style="vertical-align: middle; width: 580px; height: 418px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="580"/><p class="imgtitle" style="text-align:center;">图2-13 算子2实现效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_filter2D2_triggered（）</p><p class="content_104">{</p><p class="content_105">//算子2</p><p class="content_105">//建立核</p><p class="content_105">Mat kernel（3,3,CV_32F,Scalar（-1））;</p><p class="content_105">//分配像素值</p><p class="content_105">kernel.at＜float＞（1,1） = 8;</p><p class="content_105">//调用函数filter2D处理</p><p class="content_105">filter2D（srcImage,dstImage, srcImage.depth（）, kernel）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">3.算子3</p><p class="content" style="text-indent:2em;">该部分的实现效果如图2-14所示。</p><div class="pic"><img data-is-loaded="true" height="420" src="./images/29952-0070-0076.jpg" style="vertical-align: middle; width: 581px; height: 420px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="581"/><p class="imgtitle" style="text-align:center;">图2-14 算子3实现效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_filter2D3_triggered（）</p><p class="content_104">{</p><p class="content_105">//算子3</p><p class="content_105">//建立核</p><p class="content_105">Mat kernel（3,3,CV_32F,Scalar（-1））;</p><p class="content_105">kernel.at＜float＞（1,1） = 8.9;</p><p class="content_105">//调用filter2D函数</p><p class="content_105">filter2D（srcImage,dstImage, srcImage.depth（）, kernel）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">4.算子4</p><p class="content" style="text-indent:2em;">该部分的实现效果如图2-15所示。</p><div class="pic"><img data-is-loaded="true" height="349" src="./images/29952-0071-0077.jpg" style="vertical-align: middle; width: 483px; height: 349px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="483"/><p class="imgtitle" style="text-align:center;">图2-15 算子4实现效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_filter2D4_triggered（）</p><p class="content_104">{</p><p class="content_105">//算子4</p><p class="content_105">Mat kernel（3,3,CV_32F,cv::Scalar（0））;</p><p class="content_105">kernel.at＜float＞（1,1） = 5.0;</p><p class="content_105">kernel.at＜float＞（0,1） = -1.0;</p><p class="content_105">kernel.at＜float＞（2,1） = -1.0;</p><p class="content_105">//调用filter2D函数</p><p class="content_105">filter2D（srcImage,dstImage, srcImage.depth（）, kernel）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">5.算子5</p><p class="content" style="text-indent:2em;">该部分的实现效果如图2-16所示。</p><div class="pic"><img data-is-loaded="true" height="356" src="./images/29952-0071-0078.jpg" style="vertical-align: middle; width: 493px; height: 356px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="493"/><p class="imgtitle" style="text-align:center;">图2-16 算子5实现效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_filter2D5_triggered（）</p><p class="content_104">{</p><p class="content_105">//算子5</p><p class="content_105">Mat kernel（3,3,CV_32F,cv::Scalar（0））;</p><p class="content_105">kernel.at＜float＞（1,1） = 5.0;</p><p class="content_105">kernel.at＜float＞（1,0） = -1.0;</p><p class="content_105">kernel.at＜float＞（1,2） = -1.0;</p><p class="content_105">//调用filter2D函数</p><p class="content_105">filter2D（srcImage,dstImage, srcImage.depth（）, kernel）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">6.算子6</p><p class="content" style="text-indent:2em;">该部分的实现效果如图2-17所示。</p><div class="pic"><img data-is-loaded="true" height="411" src="./images/29952-0072-0079.jpg" style="vertical-align: middle; width: 570px; height: 411px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="570"/><p class="imgtitle" style="text-align:center;">图2-17 算子6实现效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_105">void MainWindow::on_filter2D6_triggered（）</p><p class="content_105">{</p><p class="content_108">//算子6</p><p class="content_108">Mat kernel = （Mat_＜float＞（3, 3） ＜＜ 0, -1, 0, -1, 6, -1, 0, -1, 0）;</p><p class="content_108">filter2D（srcImage,dstImage, srcImage.depth（）, kernel）;</p><p class="content_108">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><h3 class="thirdTitle" id="bw33">2.3.4 模板匹配的实现</h3><p class="content" style="text-indent:2em;">本节采用不同的匹配形式来实现模板匹配的效果，该部分的菜单如图2-18所示。</p><div class="pic"><img data-is-loaded="true" height="238" src="./images/29952-0073-0080.jpg" style="vertical-align: middle; width: 492px; height: 238px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="492"/><p class="imgtitle" style="text-align:center;">图2-18 “模板匹配”菜单</p></div><p class="content_102">1.TM_SQDIFF</p><p class="content" style="text-indent:2em;">本部分介绍TM_SQDIFF模板匹配方法。</p><p class="content" style="text-indent:2em;">依次选择菜单“模板匹配”→“TM_SQDIFF”命令会弹出如图 2-19 所示的“打开模板图像”对话框。</p><div class="pic"><img data-is-loaded="true" height="482" src="./images/29952-0073-0081.jpg" style="vertical-align: middle; width: 677px; height: 482px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="677"/><p class="imgtitle" style="text-align:center;">图2-19 “打开模板图像”对话框</p></div><p class="content" style="text-indent:2em;">在对话框内选择模板图像，主界面显示的效果如图2-20所示。</p><div class="pic"><img data-is-loaded="true" height="462" src="./images/29952-0074-0082.jpg" style="vertical-align: middle; width: 641px; height: 462px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="641"/><p class="imgtitle" style="text-align:center;">图2-20 TM_SQDIFF效果</p></div><p class="content" style="text-indent:2em;">为了在主界面内显示模板图像，在主界面的左上角添加了一个标签用于显示模板图像。</p><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionCV_TM_SQDIFF_triggered（）</p><p class="content_104">{</p><p class="content_105">//TM_SQDIFF效果</p><p class="content_105">//定义模板、结果</p><p class="content_105">Mat templ;</p><p class="content_105">Mat result;</p><p class="content_105">/* match_method只能取0～5之中的某一个值，即：</p><p class="content_108">* method=TM_SQDIFF （0）</p><p class="content_108">* method=TM_SQDIFF_NORMED （1）</p><p class="content_110">method=TM_CCORR （2）</p><p class="content_110">method=TM_CCORR_NORMED （3）</p><p class="content_110">method=TM_CCOEFF · （4）</p><p class="content_110">method=TM_CCOEFF_NORMED （5）</p><p class="content_105">*/</p><p class="content_105">//设置匹配方法</p><p class="content_105">int match_method=0;</p><p class="content_105">/**************打开模板文件***********************************/</p><p class="content_105">//注意这里在主界面的左上角添加了一个标签，专门用于显示模板图像</p><p class="content_104">QString filename = QFileDialog::getOpenFileName（this,tr（"打开模板图像"）,"", tr（"Image File（*.bmp *.jpg *.jpeg *.png）"））;</p><p class="content_105">QTextCodec *code = QTextCodec::codecForName（"gb18030"）;</p><p class="content_105">std::string name = code-＞fromUnicode（filename）.data（）;</p><p class="content_105">templ = cv::imread（name）;</p><p class="content_105">if（!templ.data）</p><p class="content_105">{</p><p class="content_108">QMessageBox msgBox;</p><p class="content_108">msgBox.setText（tr（"未找到数据"））;</p><p class="content_108">msgBox.exec（）;</p><p class="content_105">}</p><p class="content_105">else</p><p class="content_105">{</p><p class="content_108">cv::cvtColor（templ,templ,CV_BGR2RGB）;</p><p class="content_105">img = QImage（（const unsigned char*）（templ.data）,templ.cols, templ.rows, templ.cols*templ.channels（）, QImage::Format_RGB888）;</p><p class="content_108">ui-＞label3-＞clear（）;</p><p class="content_108">img= img.scaled（ui-＞label3-＞width（）, ui-＞label3-＞height（））;</p><p class="content_108">ui-＞label3-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_105">}</p><p class="content_105">/*******************打开模板文件********************************/</p><p class="content_105">//用于显示的图像</p><p class="content_105">Mat img_display;</p><p class="content_105">//复制图像srcImage到img_display</p><p class="content_105">srcImage.copyTo（ img_display ）;</p><p class="content_105">//生成结果</p><p class="content_105">int result_cols = srcImage.cols - templ.cols + 1;</p><p class="content_105">int result_rows = srcImage.rows - templ.rows + 1;</p><p class="content_105">/*</p><p class="content_105">* 需要注意，目标图像的大小为int result_cols = srcImage.cols - templ.cols+ 1;</p><p class="content_108">int result_rows = srcImage.rows - templ.rows + 1;</p><p class="content_105">这是因为模板沿着原始图像上的每一个点进行遍历，</p><p class="content_105">而产生一个目标图像内的点，</p><p class="content_105">当图像遍历到其右侧时，只能遍历到其从左侧数第</p><p class="content_105">srcImage.cols - templ.cols + 1个点。</p><p class="content_105">当图像遍历到其下侧时，只能遍历到其从上侧数第</p><p class="content_105">srcImage.rows - templ.rows + 1个点。</p><p class="content_105">*/</p><p class="content_105">result.create（ result_cols, result_rows, CV_32FC1 ）;</p><p class="content_105">//进行模板匹配操作</p><p class="content_105">cv::matchTemplate（ srcImage, templ, result, match_method ）;</p><p class="content_105">normalize（ result, result, 0, 1, NORM_MINMAX, -1, Mat（） ）;</p><p class="content_105">//使用minMaxLoc对匹配结果进行定位</p><p class="content_105">double minVal;</p><p class="content_105">double maxVal;</p><p class="content_105">Point minLoc;</p><p class="content_105">Point maxLoc;</p><p class="content_105">Point matchLoc;</p><p class="content_105">minMaxLoc（ result, &amp;minVal, &amp;maxVal, &amp;minLoc, &amp;maxLoc, Mat（） ）;</p><p class="content_105">//对于TM_SQDIFF和TM_SQDIFF_NORMED，最好的匹配是最小值，其他的是最大值</p><p class="content_105">if（ match_method == TM_SQDIFF || match_method == TM_SQDIFF_NORMED ）</p><p class="content_108">matchLoc = minLoc;</p><p class="content_105">else</p><p class="content_108">matchLoc = maxLoc;</p><p class="content_105">//处理结果</p><p class="content_104">rectangle（ img_display, matchLoc, Point（ matchLoc.x + templ.cols, matchLoc.y + templ.rows ）, Scalar::all（0）, 2, 8, 0 ）;</p><p class="content_104">rectangle（ result, matchLoc, Point（ matchLoc.x + templ.cols, matchLoc.y + templ.rows ）,</p><p class="content_105">Scalar::all（0）, 2, 8, 0 ）;</p><p class="content_105">img_display.copyTo（dstImage）;</p><p class="content_105">//显示结果</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_105">//窗口显示测试</p><p class="content_105">//char* image_window = "Source Image";</p><p class="content_105">// char* result_window = "Result window";</p><p class="content_105">// imshow（ image_window, img_display ）;</p><p class="content_105">//imshow（ result_window, result ）;</p><p class="content_104">}</p><p class="content_102">2.TM_SQDIFF_NORMED</p><p class="content" style="text-indent:2em;">本部分介绍TM_SQDIFF_NORMED模板匹配方法。</p><p class="content" style="text-indent:2em;">该部分的实现效果如图2-21所示。</p><div class="pic"><img data-is-loaded="true" height="470" src="./images/29952-0076-0083.jpg" style="vertical-align: middle; width: 652px; height: 470px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="652"/><p class="imgtitle" style="text-align:center;">图2-21 TM_SQDIFF_NORMED效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionCV_TM_SQDIFF_triggered（）</p><p class="content_104">{</p><p class="content_105">//TM_SQDIFF效果</p><p class="content_105">//定义模板、结果</p><p class="content_105">Mat templ;</p><p class="content_105">Mat result;</p><p class="content_105">/* match_method只能取0～5之中的某一个值，即：</p><p class="content_108">* method=TM_SQDIFF （0）</p><p class="content_108">* method=TM_SQDIFF_NORMED （1）</p><p class="content_110">method=TM_CCORR （2）</p><p class="content_110">method=TM_CCORR_NORMED （3）</p><p class="content_110">method=TM_CCOEFF · （4）</p><p class="content_110">method=TM_CCOEFF_NORMED （5）</p><p class="content_105">*/</p><p class="content_105">//设置匹配方法</p><p class="content_105">int match_method=1;</p><p class="content_105">//后续代码与TM_SQDIFF内代码一致，此处略。</p><p class="content_104">}</p><p class="content_102">3.TM_CCORR</p><p class="content" style="text-indent:2em;">本部分介绍TM_CCORR模板匹配方法。</p><p class="content" style="text-indent:2em;">该部分的实现效果如图2-22所示。</p><div class="pic"><img data-is-loaded="true" height="476" src="./images/29952-0077-0084.jpg" style="vertical-align: middle; width: 661px; height: 476px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="661"/><p class="imgtitle" style="text-align:center;">图2-22 TM_CCORR效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionCV_TM_SQDIFF_triggered（）</p><p class="content_104">{</p><p class="content_105">//TM_SQDIFF效果</p><p class="content_105">//定义模板、结果</p><p class="content_105">Mat templ;</p><p class="content_105">Mat result;</p><p class="content_105">/* match_method只能取0～5之中的某一个值，即：</p><p class="content_108">* method=TM_SQDIFF （0）</p><p class="content_108">* method=TM_SQDIFF_NORMED （1）</p><p class="content_110">method=TM_CCORR （2）</p><p class="content_110">method=TM_CCORR_NORMED （3）</p><p class="content_110">method=TM_CCOEFF · （4）</p><p class="content_110">method=TM_CCOEFF_NORMED （5）</p><p class="content_105">*/</p><p class="content_105">//设置匹配方法</p><p class="content_105">int match_method=2;</p><p class="content_105">//后续代码与TM_SQDIFF内代码一致，此处略。</p><p class="content_104">}</p><p class="content_102">4.TM_CCORR_NORMED</p><p class="content" style="text-indent:2em;">本部分介绍TM_CCORR_NORMED模板匹配方法。</p><p class="content" style="text-indent:2em;">该部分的实现效果如图2-23所示。</p><div class="pic"><img data-is-loaded="true" height="453" src="./images/29952-0078-0085.jpg" style="vertical-align: middle; width: 626px; height: 453px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="626"/><p class="imgtitle" style="text-align:center;">图2-23 TM_CCORR_NORMED效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionCV_TM_SQDIFF_triggered（）</p><p class="content_104">{</p><p class="content_105">//TM_SQDIFF效果</p><p class="content_105">//定义模板、结果</p><p class="content_105">Mat templ;</p><p class="content_105">Mat result;</p><p class="content_105">/* match_method只能取0～5之中的某一个值，即：</p><p class="content_108">* method=TM_SQDIFF （0）</p><p class="content_108">* method=TM_SQDIFF_NORMED （1）</p><p class="content_110">method=TM_CCORR （2）</p><p class="content_110">method=TM_CCORR_NORMED （3）</p><p class="content_110">method=TM_CCOEFF · （4）</p><p class="content_110">method=TM_CCOEFF_NORMED （5）</p><p class="content_105">*/</p><p class="content_105">//设置匹配方法</p><p class="content_105">int match_method=3;</p><p class="content_105">//后续代码与TM_SQDIFF内代码一致，此处略。</p><p class="content_104">}</p><p class="content_102">5.TM_CCOEFF</p><p class="content" style="text-indent:2em;">本部分介绍TM_CCOEFF模板匹配方法。</p><p class="content" style="text-indent:2em;">该部分的实现效果如图2-24所示。</p><div class="pic"><img data-is-loaded="true" height="458" src="./images/29952-0079-0086.jpg" style="vertical-align: middle; width: 637px; height: 458px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="637"/><p class="imgtitle" style="text-align:center;">图2-24 TM_CCOEFF效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionCV_TM_SQDIFF_triggered（）</p><p class="content_104">{</p><p class="content_105">//TM_SQDIFF效果</p><p class="content_105">//定义模板、结果</p><p class="content_105">Mat templ;</p><p class="content_105">Mat result;</p><p class="content_105">/* match_method只能取0～5之中的某一个值，即：</p><p class="content_108">* method=TM_SQDIFF （0）</p><p class="content_108">* method=TM_SQDIFF_NORMED （1）</p><p class="content_110">method=TM_CCORR （2）</p><p class="content_110">method=TM_CCORR_NORMED （3）</p><p class="content_110">method=TM_CCOEFF · （4）</p><p class="content_110">method=TM_CCOEFF_NORMED （5）</p><p class="content_105">*/</p><p class="content_105">//设置匹配方法</p><p class="content_105">int match_method=4;</p><p class="content_105">//后续代码与TM_SQDIFF内代码一致，此处略。</p><p class="content_104">}</p><p class="content_102">6.TM_CCOEFF_NORMED</p><p class="content" style="text-indent:2em;">本部分介绍TM_CCOEFF_NORMED模板匹配方法。</p><p class="content" style="text-indent:2em;">该部分的实现效果如图2-25所示。</p><div class="pic"><img data-is-loaded="true" height="415" src="./images/29952-0080-0087.jpg" style="vertical-align: middle; width: 576px; height: 415px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="576"/><p class="imgtitle" style="text-align:center;">图2-25 TM_CCOEFF_NORMED效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionCV_TM_SQDIFF_triggered（）</p><p class="content_104">{</p><p class="content_105">//TM_SQDIFF效果</p><p class="content_105">//定义模板、结果</p><p class="content_105">Mat templ;</p><p class="content_105">Mat result;</p><p class="content_105">/* match_method只能取0～5之中的某一个值，即：</p><p class="content_108">* method=TM_SQDIFF （0）</p><p class="content_108">* method=TM_SQDIFF_NORMED （1）</p><p class="content_110">method=TM_CCORR （2）</p><p class="content_110">method=TM_CCORR_NORMED （3）</p><p class="content_110">method=TM_CCOEFF · （4）</p><p class="content_110">method=TM_CCOEFF_NORMED （5）</p><p class="content_105">*/</p><p class="content_105">//设置匹配方法</p><p class="content_105">int match_method=5;</p><p class="content_105">//后续代码与TM_SQDIFF内代码一致，此处略。</p><p class="content_104">}</p><h3 class="thirdTitle" id="bw34">2.3.5 仿射变换的实现</h3><p class="content" style="text-indent:2em;">仿射变换实现了单纯仿射和旋转仿射，其菜单如图2-26所示。</p><div class="pic"><img data-is-loaded="true" height="213" src="./images/29952-0080-0088.jpg" style="vertical-align: middle; width: 463px; height: 213px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="463"/><p class="imgtitle" style="text-align:center;">图2-26 “仿射变换”菜单</p></div><p class="content_102">1.单纯仿射</p><p class="content" style="text-indent:2em;">本部分实现单纯仿射，具体的实现效果如图2-27所示。</p><div class="pic"><img data-is-loaded="true" height="415" src="./images/29952-0081-0089.jpg" style="vertical-align: middle; width: 573px; height: 415px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="573"/><p class="imgtitle" style="text-align:center;">图2-27 单纯仿射效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_wrapAffine_triggered（）</p><p class="content_104">{</p><p class="content_105">//单纯仿射</p><p class="content_105">Point2f srcTri[3];</p><p class="content_105">Point2f dstTri[3];</p><p class="content_105">Mat rot_mat（ 2, 3, CV_32FC1 ）;</p><p class="content_105">Mat warp_mat（ 2, 3, CV_32FC1 ）;</p><p class="content_105">Mat src, warp_dst, warp_rotate_dst;</p><p class="content_105">//读入图像</p><p class="content_105">srcImage.copyTo（src）;</p><p class="content_105">warp_dst = Mat::zeros（ src.rows, src.cols, src.type（） ）;</p><p class="content_105">//用3个点确定A仿射变换</p><p class="content_105">srcTri[0] = Point2f（ 0,0 ）;</p><p class="content_105">srcTri[1] = Point2f（ src.cols - 1, 0 ）;</p><p class="content_105">srcTri[2] = Point2f（ 0, src.rows - 1 ）;</p><p class="content_105">dstTri[0] = Point2f（ src.cols*0.0, src.rows*0.33 ）;</p><p class="content_105">dstTri[1] = Point2f（ src.cols*0.85, src.rows*0.25 ）;</p><p class="content_105">dstTri[2] = Point2f（ src.cols*0.15, src.rows*0.7 ）;</p><p class="content_105">warp_mat = getAffineTransform（ srcTri, dstTri ）;</p><p class="content_105">warpAffine（ src, warp_dst, warp_mat, warp_dst.size（） ）;</p><p class="content_105">warp_dst.copyTo（dstImage）;</p><p class="content_105">//显示仿射结果</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">2.旋转仿射</p><p class="content" style="text-indent:2em;">本部分实现旋转仿射，具体的实现效果如图2-28所示。</p><div class="pic"><img data-is-loaded="true" height="428" src="./images/29952-0082-0090.jpg" style="vertical-align: middle; width: 593px; height: 428px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="593"/><p class="imgtitle" style="text-align:center;">图2-28 旋转仿射效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_rotateWrapAffine_triggered（）</p><p class="content_104">{</p><p class="content_105">//旋转仿射</p><p class="content_105">Point2f srcTri[3];</p><p class="content_105">Point2f dstTri[3];</p><p class="content_105">Mat rot_mat（ 2, 3, CV_32FC1 ）;</p><p class="content_105">Mat warp_mat（ 2, 3, CV_32FC1 ）;</p><p class="content_105">Mat src, warp_dst, warp_rotate_dst;</p><p class="content_105">//读入图像</p><p class="content_105">srcImage.copyTo（src）;</p><p class="content_105">warp_dst = Mat::zeros（ src.rows, src.cols, src.type（） ）;</p><p class="content_105">//用3个点确定A仿射变换</p><p class="content_105">srcTri[0] = Point2f（ 0,0 ）;</p><p class="content_105">srcTri[1] = Point2f（ src.cols - 1, 0 ）;</p><p class="content_105">srcTri[2] = Point2f（ 0, src.rows - 1 ）;</p><p class="content_105">dstTri[0] = Point2f（ src.cols*0.0, src.rows*0.33 ）;</p><p class="content_105">dstTri[1] = Point2f（ src.cols*0.85, src.rows*0.25 ）;</p><p class="content_105">dstTri[2] = Point2f（ src.cols*0.15, src.rows*0.7 ）;</p><p class="content_105">warp_mat = getAffineTransform（ srcTri, dstTri ）;</p><p class="content_105">warpAffine（ src, warp_dst, warp_mat, warp_dst.size（） ）;</p><p class="content_105">// 旋转矩阵</p><p class="content_105">Point center = Point（ warp_dst.cols/2, warp_dst.rows/2 ）;</p><p class="content_105">double angle = -50.0;</p><p class="content_105">double scale = 0.6;</p><p class="content_105">rot_mat = getRotationMatrix2D（ center, angle, scale ）;</p><p class="content_105">warpAffine（ warp_dst, warp_rotate_dst, rot_mat, warp_dst.size（） ）;</p><p class="content_105">&amp;M,CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,cvScalarAll（0） ）;</p><p class="content_105">warp_rotate_dst.copyTo（dstImage）;</p><p class="content_105">//显示结果图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><h3 class="thirdTitle" id="bw35">2.3.6 重映射的实现</h3><p class="content" style="text-indent:2em;">重映射实现了复制、x轴、y轴、缩小、旋转、xy轴互换等多种形式重映射的操作，该部分的菜单如图2-29所示。</p><div class="pic"><img data-is-loaded="true" height="199" src="./images/29952-0083-0091.jpg" style="vertical-align: middle; width: 378px; height: 199px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="378"/><p class="imgtitle" style="text-align:center;">图2-29 “重映射”菜单</p></div><p class="content_102">1.复制</p><p class="content" style="text-indent:2em;">复制，即通过重映射的方式来实现图像的复制功能。该部分的实现效果如图2-30所示。</p><div class="pic"><img data-is-loaded="true" height="394" src="./images/29952-0083-0092.jpg" style="vertical-align: middle; width: 545px; height: 394px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="545"/><p class="imgtitle" style="text-align:center;">图2-30 复制效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_remapCopy_triggered（）</p><p class="content_104">{</p><p class="content_105">//复制</p><p class="content_105">//定义映射</p><p class="content_105">Mat map_x, map_y;</p><p class="content_105">dstImage.create（ srcImage.size（）, srcImage.type（） ）;</p><p class="content_105">map_x.create（ srcImage.size（）, CV_32FC1 ）;</p><p class="content_105">map_y.create（ srcImage.size（）, CV_32FC1 ）;</p><p class="content_105">for（ int i = 0; i ＜ srcImage.rows; i++ ）</p><p class="content_105">{</p><p class="content_108">for（ int j = 0; j ＜ srcImage.cols; j++ ）</p><p class="content_108">{</p><p class="content_110">map_x.at＜float＞（i,j） = j;</p><p class="content_110">map_y.at＜float＞（i,j） = i;</p><p class="content_108">}</p><p class="content_105">}</p><p class="content_105">//调用remap</p><p class="content_105">remap（ srcImage, dstImage, map_x, map_y,</p><p class="content_108">CV_INTER_LINEAR, BORDER_CONSTANT, Scalar（0,0, 0） ）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">2.x轴</p><p class="content" style="text-indent:2em;">x轴重映射，在x轴的方向上完成重映射。该部分的实现效果如图2-31所示。</p><div class="pic"><img data-is-loaded="true" height="387" src="./images/29952-0084-0093.jpg" style="vertical-align: middle; width: 534px; height: 387px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="534"/><p class="imgtitle" style="text-align:center;">图2-31 x轴效果图</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_remapX_triggered（）</p><p class="content_104">{</p><p class="content_105">//x轴</p><p class="content_105">//定义映射</p><p class="content_105">Mat map_x, map_y;</p><p class="content_105">dstImage.create（ srcImage.size（）, srcImage.type（） ）;</p><p class="content_105">map_x.create（ srcImage.size（）, CV_32FC1 ）;</p><p class="content_105">map_y.create（ srcImage.size（）, CV_32FC1 ）;</p><p class="content_105">for（ int i = 0; i ＜ srcImage.rows; i++ ）</p><p class="content_105">{</p><p class="content_108">for（ int j = 0; j ＜ srcImage.cols; j++ ）</p><p class="content_108">{</p><p class="content_110">map_x.at＜float＞（i,j） = srcImage.cols - j;</p><p class="content_110">map_y.at＜float＞（i,j） = i;</p><p class="content_108">}</p><p class="content_105">}</p><p class="content_105">//调用remap</p><p class="content_105">remap（ srcImage, dstImage, map_x, map_y,</p><p class="content_105">CV_INTER_LINEAR, BORDER_CONSTANT, Scalar（0,0, 0） ）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">3.y轴</p><p class="content" style="text-indent:2em;">y轴重映射，在y轴的方向上实现重映射。该部分的实现效果如图2-32所示。</p><div class="pic"><img data-is-loaded="true" height="394" src="./images/29952-0085-0094.jpg" style="vertical-align: middle; width: 543px; height: 394px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="543"/><p class="imgtitle" style="text-align:center;">图2-32 y轴效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_remapY_triggered（）</p><p class="content_104">{</p><p class="content_105">//y轴</p><p class="content_105">//定义映射</p><p class="content_105">Mat map_x, map_y;</p><p class="content_105">dstImage.create（ srcImage.size（）, srcImage.type（） ）;</p><p class="content_105">map_x.create（ srcImage.size（）, CV_32FC1 ）;</p><p class="content_105">map_y.create（ srcImage.size（）, CV_32FC1 ）;</p><p class="content_105">for（ int i = 0; i ＜ srcImage.rows; i++ ）</p><p class="content_105">{</p><p class="content_108">for（ int j = 0; j ＜ srcImage.cols; j++ ）</p><p class="content_108">{</p><p class="content_110">map_x.at＜float＞（i,j） = j;</p><p class="content_110">map_y.at＜float＞（i,j） = srcImage.rows -i;</p><p class="content_108">}</p><p class="content_105">}</p><p class="content_105">//调用remap</p><p class="content_105">remap（ srcImage, dstImage, map_x, map_y, CV_INTER_LINEAR,</p><p class="content_105">BORDER_CONSTANT, Scalar（0,0, 0） ）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">4.缩小</p><p class="content" style="text-indent:2em;">缩小，即通过缩小的方式实现重映射。其他点使用图像内的某一个像素点填充实现。该部分的实现效果如图2-33所示。</p><div class="pic"><img data-is-loaded="true" height="414" src="./images/29952-0086-0095.jpg" style="vertical-align: middle; width: 571px; height: 414px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="571"/><p class="imgtitle" style="text-align:center;">图2-33 缩小效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_remapSmall_triggered（）</p><p class="content_104">{</p><p class="content_105">//缩小</p><p class="content_105">//定义映射</p><p class="content_105">Mat map_x, map_y;</p><p class="content_105">dstImage.create（ srcImage.size（）, srcImage.type（） ）;</p><p class="content_105">map_x.create（ srcImage.size（）, CV_32FC1 ）;</p><p class="content_105">map_y.create（ srcImage.size（）, CV_32FC1 ）;</p><p class="content_105">for（ int i = 0; i ＜ srcImage.rows; i++ ）</p><p class="content_105">{</p><p class="content_108">for（ int j = 0; j ＜ srcImage.cols; j++ ）</p><p class="content_108">{</p><p class="content_110">if（ i ＞ srcImage.rows*0.25 &amp;&amp; i ＜ srcImage.rows*0.75</p><p class="content_111">&amp;&amp;j ＞ srcImage.cols*0.25 &amp;&amp;j ＜ srcImage.cols*0.75 ）</p><p class="content_108">{</p><p class="content_110">map_x.at＜float＞（i,j） = 2*（ j - srcImage.cols*0.25 ） + 0.5;</p><p class="content_110">map_y.at＜float＞（i,j） = 2*（ i - srcImage.rows*0.25 ） + 0.5;</p><p class="content_108">}</p><p class="content_108">else</p><p class="content_108">{</p><p class="content_110">map_x.at＜float＞（i,j） = 1; //随机选取</p><p class="content_110">map_y.at＜float＞（i,j） = 1; //随机选取</p><p class="content_108">}</p><p class="content_105">}</p><p class="content_104">}</p><p class="content_104">//调用remap</p><p class="content_104">remap（ srcImage, dstImage, map_x, map_y, CV_INTER_LINEAR,</p><p class="content_104">BORDER_CONSTANT, Scalar（0,0, 0） ）;</p><p class="content_104">//显示图像</p><p class="content_104">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_104">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_104">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_112">}</p><p class="content_102">5.旋转</p><p class="content" style="text-indent:2em;">旋转，使用重映射的方式实现图像的旋转效果。该部分的实现效果如图2-34所示。</p><div class="pic"><img data-is-loaded="true" height="404" src="./images/29952-0087-0096.jpg" style="vertical-align: middle; width: 557px; height: 404px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="557"/><p class="imgtitle" style="text-align:center;">图2-34 旋转效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_remapRotate_triggered（）</p><p class="content_104">{</p><p class="content_105">//旋转</p><p class="content_105">//定义映射</p><p class="content_105">Mat map_x, map_y;</p><p class="content_105">dstImage.create（ srcImage.size（）, srcImage.type（） ）;</p><p class="content_105">map_x.create（ srcImage.size（）, CV_32FC1 ）;</p><p class="content_105">map_y.create（ srcImage.size（）, CV_32FC1 ）;</p><p class="content_105">for（ int i = 0; i ＜ srcImage.rows; i++ ）</p><p class="content_105">{</p><p class="content_108">for（ int j = 0; j ＜ srcImage.cols; j++ ）</p><p class="content_108">{</p><p class="content_110">map_x.at＜float＞（i,j） = srcImage.cols - j;</p><p class="content_110">map_y.at＜float＞（i,j） = srcImage.rows -i;</p><p class="content_108">}</p><p class="content_105">}</p><p class="content_105">//调用remap</p><p class="content_105">remap（ srcImage, dstImage, map_x, map_y, CV_INTER_LINEAR,</p><p class="content_105">BORDER_CONSTANT, Scalar（0,0, 0） ）;</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">6.xy轴互换</p><p class="content" style="text-indent:2em;">xy轴互换，使用重映射的方式实现图像的x轴方向、y轴方向像素互换。该部分的实现效果如图2-35所示。</p><div class="pic"><img data-is-loaded="true" height="394" src="./images/29952-0088-0097.jpg" style="vertical-align: middle; width: 543px; height: 394px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="543"/><p class="imgtitle" style="text-align:center;">图2-35 xy轴互换效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_remapDiagonal_triggered（）</p><p class="content_104">{</p><p class="content_105">//xy轴互换</p><p class="content_105">//定义映射</p><p class="content_105">Mat map_x, map_y;</p><p class="content_105">dstImage.create（ srcImage.size（）, srcImage.type（） ）;</p><p class="content_105">map_x.create（ srcImage.size（）, CV_32FC1 ）;</p><p class="content_105">map_y.create（ srcImage.size（）, CV_32FC1 ）;</p><p class="content_105">for（ int i = 0; i ＜ srcImage.rows; i++ ）</p><p class="content_105">{</p><p class="content_108">for（ int j = 0; j ＜ srcImage.cols; j++ ）</p><p class="content_108">{</p><p class="content_110">map_x.at＜float＞（i,j） = i;</p><p class="content_110">map_y.at＜float＞（i,j） = j;</p><p class="content_108">}</p><p class="content_105">}</p><p class="content_105">//调用remap</p><p class="content_105">remap（ srcImage, dstImage, map_x, map_y, CV_INTER_LINEAR,</p><p class="content_105">BORDER_CONSTANT, Scalar（0,0, 0） ）;</p><p class="content_105">//显示图像</p><p class="content_104">img = QImage（（const unsigned char*） （dstImage.data）,dstImage.cols, dstImage.rows,dstImage.cols*dstImage.channels（）, QImage::Format_RGB888）;</p><p class="content_105">img=img.scaled（ui-＞label1-＞size（））;</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><h3 class="thirdTitle" id="bw36">2.3.7 分割的实现</h3><p class="content" style="text-indent:2em;">本节实现了多种方式的分割，该部分的菜单如图2-36所示。</p><div class="pic"><img data-is-loaded="true" height="192" src="./images/29952-0089-0098.jpg" style="vertical-align: middle; width: 513px; height: 192px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="513"/><p class="imgtitle" style="text-align:center;">图2-36 “分割”菜单</p></div><p class="content_102">1.threshold</p><p class="content" style="text-indent:2em;">该部分实现了对threshold函数的各种阈值分割类型的演示，其菜单如图2-37所示。</p><div class="pic"><img data-is-loaded="true" height="219" src="./images/29952-0089-0099.jpg" style="vertical-align: middle; width: 502px; height: 219px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="502"/><p class="imgtitle" style="text-align:center;">图2-37 “threshold”菜单</p></div><p class="content" style="text-indent:2em;">（1）THRESH_BINARY</p><p class="content" style="text-indent:2em;">该部分实现了threshold函数内THRESH_BINARY类型的阈值分割，效果如图2-38所示。</p><div class="pic"><img data-is-loaded="true" height="440" src="./images/29952-0090-0100.jpg" style="vertical-align: middle; width: 601px; height: 440px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="601"/><p class="imgtitle" style="text-align:center;">图2-38 THRESH_BINARY效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_BINARY_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：threshold=＞THRESH_BINARY</p><p class="content_105">//定义Mat，用于存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_BINARY;</p><p class="content_105">/***********等价于************/</p><p class="content_105">//int threshold_type=0;</p><p class="content_105">/***********等价于************/</p><p class="content_105">//调用threshold函数</p><p class="content_104">threshold（srcGray, dstImage, threshold_value, max_BINARY_value, threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试效果</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">//img=img.scaled（ui-＞label1-＞size（））; //缩放图像</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（2）THRESH_BINARY_INV</p><p class="content" style="text-indent:2em;">该部分实现了threshold函数内THRESH_BINARY_INV类型的阈值分割，该部分的实现效果如图2-39所示。</p><div class="pic"><img data-is-loaded="true" height="401" src="./images/29952-0091-0101.jpg" style="vertical-align: middle; width: 547px; height: 401px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="547"/><p class="imgtitle" style="text-align:center;">图2-39 THRESH_BINARY_INV效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_BINARY_INV_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：threshold=＞THRESH_BINARY_INV</p><p class="content_105">//定义Mat，用于存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_BINARY_INV;</p><p class="content_105">/***********等价于************/</p><p class="content_105">//int threshold_type=0;</p><p class="content_105">/***********等价于************/</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value, threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试效果</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">//img=img.scaled（ui-＞label1-＞size（））; //缩放图像</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（3）THRESH_TRUNC</p><p class="content" style="text-indent:2em;">该部分实现了threshold函数内THRESH_TRUNC类型的阈值分割，该部分的实现效果如图2-40所示。</p><div class="pic"><img data-is-loaded="true" height="399" src="./images/29952-0092-0102.jpg" style="vertical-align: middle; width: 547px; height: 399px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="547"/><p class="imgtitle" style="text-align:center;">图2-40 THRESH_TRUNC效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_TRUNC_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：threshold=＞THRESH_TRUNC</p><p class="content_105">//定义Mat，用于存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_TRUNC;</p><p class="content_105">/***********等价于************/</p><p class="content_105">//int threshold_type=0;</p><p class="content_105">/***********等价于************/</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value, threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试效果</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols,dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">//img=img.scaled（ui-＞label1-＞size（））; //缩放图像</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（4）THRESH_TOZERO</p><p class="content" style="text-indent:2em;">该部分实现了threshold函数内THRESH_TOZERO类型的阈值分割，该部分的实现效果如图2-41所示。</p><div class="pic"><img data-is-loaded="true" height="403" src="./images/29952-0093-0103.jpg" style="vertical-align: middle; width: 548px; height: 403px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="548"/><p class="imgtitle" style="text-align:center;">图2-41 THRESH_TOZERO效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_TOZERO_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：threshold=＞THRESH_TOZERO</p><p class="content_105">//定义Mat，用于存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_TOZERO;</p><p class="content_105">/***********等价于************/</p><p class="content_105">//int threshold_type=0;</p><p class="content_105">/***********等价于************/</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value, threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试效果</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols,dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">//img=img.scaled（ui-＞label1-＞size（））; //缩放图像</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（5）THRESH_TOZERO_INV</p><p class="content" style="text-indent:2em;">该部分实现了threshold函数内THRESH_TOZERO_INV类型的阈值分割，该部分的实现效果如图2-42所示。</p><div class="pic"><img data-is-loaded="true" height="383" src="./images/29952-0094-0104.jpg" style="vertical-align: middle; width: 525px; height: 383px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="525"/><p class="imgtitle" style="text-align:center;">图2-42 THRESH_TOZERO_INV效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_TOZERO_INV_2_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：threshold=＞THRESH_TOZERO_INV</p><p class="content_105">//定义Mat，用于存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_TOZERO_INV;</p><p class="content_105">/***********等价于************/</p><p class="content_105">//int threshold_type=0;</p><p class="content_105">/***********等价于************/</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value, threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试效果</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols,dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">//img=img.scaled（ui-＞label1-＞size（））; //缩放图像</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">2.THRESH_OTSU</p><p class="content" style="text-indent:2em;">在threshold函数中，参数THRESH_OTSU通常是与基本参数组合使用的，本部分实现了该参数与基本参数的组合使用，该部分的菜单如图2-43所示。</p><div class="pic"><img data-is-loaded="true" height="243" src="./images/29952-0095-0105.jpg" style="vertical-align: middle; width: 494px; height: 243px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="494"/><p class="imgtitle" style="text-align:center;">图2-43 “THRESH_OTSU”菜单</p></div><p class="content" style="text-indent:2em;">（1）THRESH_BINARY</p><p class="content" style="text-indent:2em;">该部分所使用的参数组合为“THRESH_BINARY+THRESH_OTSU”，其实现效果如图2-44所示。</p><div class="pic"><img data-is-loaded="true" height="433" src="./images/29952-0095-0106.jpg" style="vertical-align: middle; width: 591px; height: 433px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="591"/><p class="imgtitle" style="text-align:center;">图2-44 THRESH_BINARY+THRESH_OTSU效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_BINARY_3_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：THRESH_OTSU=＞TRESH_BINARY</p><p class="content_105">//THRESH_BINARY+THRESH_OTSU</p><p class="content_105">//定义灰度Mat，用户存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换，彩色变灰度</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数值</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_BINARY+THRESH_OTSU;</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value, threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试一下</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（2）THRESH_BINARY_INV</p><p class="content" style="text-indent:2em;">该部分所使用的参数组合为“THRESH_BINARY_INV+THRESH_OTSU”，其实现效果如图2-45所示。</p><div class="pic"><img data-is-loaded="true" height="402" src="./images/29952-0096-0107.jpg" style="vertical-align: middle; width: 549px; height: 402px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="549"/><p class="imgtitle" style="text-align:center;">图2-45 THRESH_BINARY_INV+THRESH_OTSU效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_BINARY_INV_3_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：THRESH_OTSU=＞THRESH_BINARY_INV</p><p class="content_105">//THRESH_BINARY_INV+THRESH_OTSU;</p><p class="content_105">//定义灰度Mat，用户存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换，彩色变灰度</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数值</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_BINARY_INV+THRESH_OTSU;</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value, threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试一下</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（3）THRESH_TRUNC</p><p class="content" style="text-indent:2em;">该部分所使用的参数组合为“THRESH_TRUNC+THRESH_OTSU”，其实现效果如图2-46所示。</p><div class="pic"><img data-is-loaded="true" height="424" src="./images/29952-0097-0108.jpg" style="vertical-align: middle; width: 580px; height: 424px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="580"/><p class="imgtitle" style="text-align:center;">图2-46 THRESH_TRUNC+THRESH_OTSU效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_TRUNC_2_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：THRESH_OTSU=＞THRESH_TRUNC</p><p class="content_105">//THRESH_TRUNC+THRESH_OTSU</p><p class="content_105">//定义灰度Mat，用户存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换，彩色变灰度</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数值</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_TRUNC+THRESH_OTSU;</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value,threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试一下</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（4）THRESH_TOZERO</p><p class="content" style="text-indent:2em;">该部分所使用的参数为“THRESH_TOZERO+THRESH_OTSU”，其所实现的效果如图2-47所示。</p><div class="pic"><img data-is-loaded="true" height="443" src="./images/29952-0098-0109.jpg" style="vertical-align: middle; width: 605px; height: 443px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="605"/><p class="imgtitle" style="text-align:center;">图2-47 THRESH_TOZERO+THRESH_OTSU效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_TOZERO_2_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：THRESH_OTSU=＞THRESH_TOZERO</p><p class="content_105">//THRESH_TOZERO+THRESH_OTSU</p><p class="content_105">//定义灰度Mat，用户存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换，彩色变灰度</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数值</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_TOZERO+THRESH_OTSU;</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value,threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试一下</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（5）THRESH_TOZERO_INV</p><p class="content" style="text-indent:2em;">该部分所使用的参数为“THRESH_TOZERO_INV+THRESH_OTSU”，其实现效果如图2-48所示。</p><div class="pic"><img data-is-loaded="true" height="438" src="./images/29952-0099-0110.jpg" style="vertical-align: middle; width: 599px; height: 438px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="599"/><p class="imgtitle" style="text-align:center;">图2-48 THRESH_TOZERO_INV+THRESH_OTSU效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_TOZERO_INV_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：THRESH_OTSU=＞THRESH_TOZERO_INV</p><p class="content_105">//THRESH_TOZERO_INV+THRESH_OTSU</p><p class="content_105">//定义灰度Mat，用户存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换，彩色变灰度</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数值</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_TOZERO_INV+THRESH_OTSU;</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value,threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试一下</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">3.THRESH_TRIANGLE</p><p class="content" style="text-indent:2em;">参数 THRESH_TRIANGLE 要和基本参数组合使用，本部分实现该参数与基本参数组合使用的效果，该部分的菜单如图2-49所示。</p><div class="pic"><img data-is-loaded="true" height="239" src="./images/29952-0100-0111.jpg" style="vertical-align: middle; width: 458px; height: 239px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="458"/><p class="imgtitle" style="text-align:center;">图2-49 “THRESH_TRIANGLE”菜单</p></div><p class="content" style="text-indent:2em;">（1）THRESH_BINARY</p><p class="content" style="text-indent:2em;">该部分使用参数组合“THRESH_BINARY+THRESH_TRIANGLE”，其实现效果如图2-50所示。</p><div class="pic"><img data-is-loaded="true" height="438" src="./images/29952-0100-0112.jpg" style="vertical-align: middle; width: 601px; height: 438px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="601"/><p class="imgtitle" style="text-align:center;">图2-50 THRESH_BINARY+THRESH_TRIANGLE效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_BINARY_2_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：THRESH_TRIANGLE=＞TRESH_BINARY</p><p class="content_105">//THRESH_BINARY+THRESH_TRIANGLE</p><p class="content_105">//定义灰度Mat，用户存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换，彩色变灰度</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数值</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_BINARY+THRESH_TRIANGLE;</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value, threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试一下</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（2）THRESH_BINARY_INV</p><p class="content" style="text-indent:2em;">该部分使用参数组合“THRESH_BINARY_INV+THRESH_TRIANGLE”，其实现效果如图2-51所示。</p><div class="pic"><img data-is-loaded="true" height="441" src="./images/29952-0101-0113.jpg" style="vertical-align: middle; width: 604px; height: 441px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="604"/><p class="imgtitle" style="text-align:center;">图2-51 THRESH_BINARY_INV+THRESH_TRIANGLE效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_BINARY_INV_2_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：THRESH_TRIANGLE=＞THRESH_BINARY_INV</p><p class="content_105">//THRESH_BINARY_INV+THRESH_TRIANGLE</p><p class="content_105">//定义灰度Mat，用户存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换，彩色变灰度</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数值</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_BINARY_INV+THRESH_TRIANGLE;</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value, threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试一下</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（3）THRESH_TRUNC</p><p class="content" style="text-indent:2em;">该部分所使用的参数组合为“THRESH_TRUNC+THRESH_TRIANGLE”，其实现效果如图2-52所示。</p><div class="pic"><img data-is-loaded="true" height="510" src="./images/29952-0102-0114.jpg" style="vertical-align: middle; width: 700px; height: 510px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="700"/><p class="imgtitle" style="text-align:center;">图2-52 THRESH_TRUNC+THRESH_TRIANGLE效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_TRUNC_3_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：THRESH_TRIANGLE=＞THRESH_TRUNC</p><p class="content_105">//THRESH_TRUNC+THRESH_TRIANGLE</p><p class="content_105">//定义灰度Mat，用户存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换，彩色变灰度</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数值</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_TRUNC+THRESH_TRIANGLE;</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value, threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试一下</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（4）THRESH_TOZERO</p><p class="content" style="text-indent:2em;">该部分所使用的参数组合为“THRESH_TOZERO+THRESH_TRIANGLE”，其实现效果如图2-53所示。</p><div class="pic"><img data-is-loaded="true" height="452" src="./images/29952-0103-0115.jpg" style="vertical-align: middle; width: 619px; height: 452px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="619"/><p class="imgtitle" style="text-align:center;">图2-53 THRESH_TOZERO+THRESH_TRIANGLE效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_TOZERO_3_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：THRESH_TRIANGLE=＞THRESH_TOZERO</p><p class="content_105">//THRESH_TOZERO+THRESH_TRIANGLE</p><p class="content_105">//定义灰度Mat，用户存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换，彩色变灰度</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数值</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_TOZERO+THRESH_TRIANGLE;</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value, threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试一下</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（5）THRESH_TOZERO_INV</p><p class="content" style="text-indent:2em;">该部分所使用的参数组合为“THRESH_TOZERO_INV+THRESH_TRIANGLE”，其实现效果如图2-54所示。</p><div class="pic"><img data-is-loaded="true" height="445" src="./images/29952-0104-0116.jpg" style="vertical-align: middle; width: 609px; height: 445px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="609"/><p class="imgtitle" style="text-align:center;">图2-54 THRESH_TOZERO_INV+THRESH_TRIANGLE效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionTHRESH_TOZERO_INV_3_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：THRESH_TRIANGLE=＞THRESH_TOZERO_INV</p><p class="content_105">//THRESH_TOZERO_INV+THRESH_TRIANGLE</p><p class="content_105">//定义灰度Mat，用户存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换，彩色变灰度</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//定义参数值</p><p class="content_105">int threshold_value=128;</p><p class="content_105">int max_BINARY_value=255;</p><p class="content_105">int threshold_type=THRESH_TOZERO_INV+THRESH_TRIANGLE;</p><p class="content_105">//调用threshold函数</p><p class="content_105">threshold（srcGray, dstImage, threshold_value, max_BINARY_value, threshold_type ）;</p><p class="content_105">// imshow（"li",dstImage）; //测试一下</p><p class="content_105">//显示图像</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content_102">4.adaptiveThreshold</p><p class="content" style="text-indent:2em;">本部分介绍自适应阈值分割函数adaptiveThreshold中使用不同参数的实现效果，具体情况介绍如下。</p><p class="content" style="text-indent:2em;">（1）THRESH_BINARY</p><p class="content" style="text-indent:2em;">该部分包含 ADAPTIVE_THRESH_MEAN_C 和 ADAPTIVE_THRESH_GAUSSIAN_C两种参数形式，该部分的菜单如图2-55所示。</p><div class="pic"><img data-is-loaded="true" height="197" src="./images/29952-0105-0117.jpg" style="vertical-align: middle; width: 554px; height: 197px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="554"/><p class="imgtitle" style="text-align:center;">图2-55 “THRESH_BINARY”菜单</p></div><p class="content" style="text-indent:2em;">●形式1：ADAPTIVE_THRESH_MEAN_C参数</p><p class="content" style="text-indent:2em;">该部分使用ADAPTIVE_THRESH_MEAN_C参数，其实现效果如图2-56所示。</p><div class="pic"><img data-is-loaded="true" height="432" src="./images/29952-0106-0118.jpg" style="vertical-align: middle; width: 590px; height: 432px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="590"/><p class="imgtitle" style="text-align:center;">图2-56 ADAPTIVE_THRESH_MEAN_C参数效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionADAPTIVE_THRESH_MEAN_C_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：adaptiveThreshold=＞THRESH_BINARY=＞ADAPTIVE_THRESH_MEAN_C</p><p class="content_105">//定义一个Mat，用于存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//参数设定</p><p class="content_105">int maxValue=255;</p><p class="content_105">int adaptiveMethod=ADAPTIVE_THRESH_MEAN_C;</p><p class="content_105">int thresholdType=THRESH_BINARY;</p><p class="content_105">int blocksize=7;</p><p class="content_105">double C=1;</p><p class="content_105">//调用adaptiveThreshold函数</p><p class="content_105">adaptiveThreshold（srcGray, dstImage, maxValue,</p><p class="content_105">adaptiveMethod,thresholdType,blocksize,C ）;</p><p class="content_105">//显示图像</p><p class="content_105">// imshow（"li",dstImage）; //测试显示情况</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">●形式2：ADAPTIVE_THRESH_GAUSSIAN_C参数</p><p class="content" style="text-indent:2em;">该部分使用ADAPTIVE_THRESH_GAUSSIAN_C参数，其实现效果如图2-57所示。</p><div class="pic"><img data-is-loaded="true" height="433" src="./images/29952-0107-0119.jpg" style="vertical-align: middle; width: 591px; height: 433px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="591"/><p class="imgtitle" style="text-align:center;">图2-57 ADAPTIVE_THRESH_GAUSSIAN_C参数效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionADAPTIVE_THRESH_GAUSSIAN_C_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：adaptiveThreshold=＞THRESH_BINARY=＞ADAPTIVE_THRESH_GAUSSIAN_C</p><p class="content_105">//定义一个Mat，用于存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//参数设定</p><p class="content_105">int maxValue=255;</p><p class="content_105">int adaptiveMethod=ADAPTIVE_THRESH_GAUSSIAN_C;</p><p class="content_105">int thresholdType=THRESH_BINARY;</p><p class="content_105">int blocksize=7;</p><p class="content_105">double C=1;</p><p class="content_105">//调用adaptiveThreshold函数</p><p class="content_105">adaptiveThreshold（srcGray, dstImage, maxValue,</p><p class="content_105">adaptiveMethod,thresholdType,blocksize,C ）;</p><p class="content_105">//显示图像</p><p class="content_105">// imshow（"li",dstImage）; //测试显示情况</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">（2）THRESH_BINARY_INV</p><p class="content" style="text-indent:2em;">该部分包含ADAPTIVE_THRESH_MEAN_C和ADAPTIVE_THRESH_GAUSSIAN_C两种参数形式，该部分的菜单如图2-58所示。</p><div class="pic"><img data-is-loaded="true" height="222" src="./images/29952-0108-0120.jpg" style="vertical-align: middle; width: 613px; height: 222px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="613"/><p class="imgtitle" style="text-align:center;">图2-58 “THRESH_BINARY_INV”菜单</p></div><p class="content" style="text-indent:2em;">●形式1：ADAPTIVE_THRESH_MEAN_C参数</p><p class="content" style="text-indent:2em;">该部分使用ADAPTIVE_THRESH_MEAN_C参数，其实现效果如图2-59所示。</p><div class="pic"><img data-is-loaded="true" height="368" src="./images/29952-0108-0121.jpg" style="vertical-align: middle; width: 501px; height: 368px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="501"/><p class="imgtitle" style="text-align:center;">图2-59 ADAPTIVE_THRESH_MEAN_C参数效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionADAPTIVE_THRESH_MEAN_C_2_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：adaptiveThreshold=＞THRESH_BINARY_INV=＞ADAPTIVE_THRESH_MEAN_C</p><p class="content_105">//定义一个Mat，用于存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//参数设定</p><p class="content_105">int maxValue=255;</p><p class="content_105">int adaptiveMethod=ADAPTIVE_THRESH_MEAN_C;</p><p class="content_105">int thresholdType=THRESH_BINARY_INV;</p><p class="content_105">int blocksize=7;</p><p class="content_105">double C=1;</p><p class="content_105">//调用adaptiveThreshold函数</p><p class="content_105">adaptiveThreshold（srcGray, dstImage, maxValue,</p><p class="content_105">adaptiveMethod,thresholdType,blocksize,C ）;</p><p class="content_105">//显示图像</p><p class="content_105">// imshow（"li",dstImage）; //测试显示情况</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols, dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><p class="content" style="text-indent:2em;">●形式2：ADAPTIVE_THRESH_GAUSSIAN_C参数</p><p class="content" style="text-indent:2em;">该部分使用ADAPTIVE_THRESH_GAUSSIAN_C参数，其实现效果如图2-60所示。</p><div class="pic"><img data-is-loaded="true" height="359" src="./images/29952-0109-0122.jpg" style="vertical-align: middle; width: 490px; height: 359px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="490"/><p class="imgtitle" style="text-align:center;">图2-60 ADAPTIVE_THRESH_GAUSSIAN_C参数效果</p></div><p class="content" style="text-indent:2em;">该部分的实现代码为：</p><p class="content_104">void MainWindow::on_actionADAPTIVE_THRESH_GAUSSIAN_C_2_triggered（）</p><p class="content_104">{</p><p class="content_105">//菜单：adaptiveThreshold=＞THRESH_BINARY_INV=＞ADAPTIVE_THRESH_</p><p class="content_104">//GAUSSIAN_C</p><p class="content_105">//定义一个Mat，用于存储灰度图像</p><p class="content_105">Mat srcGray;</p><p class="content_105">//调整大小</p><p class="content_105">cv::resize（srcImage,srcImage,Size（ui-＞label1-＞width（）, ui-＞label1-＞height（））,0,0,3）;</p><p class="content_105">//色彩空间转换</p><p class="content_105">cvtColor（srcImage,srcGray,COLOR_RGB2GRAY）;</p><p class="content_105">//参数设定</p><p class="content_105">int maxValue=255;</p><p class="content_105">int adaptiveMethod=ADAPTIVE_THRESH_GAUSSIAN_C;</p><p class="content_105">int thresholdType=THRESH_BINARY_INV;</p><p class="content_105">int blocksize=7;</p><p class="content_105">double C=1;</p><p class="content_105">//调用adaptiveThreshold函数</p><p class="content_105">adaptiveThreshold（srcGray, dstImage, maxValue,</p><p class="content_105">adaptiveMethod,thresholdType,blocksize,C ）;</p><p class="content_105">//显示图像</p><p class="content_105">// imshow（"li",dstImage）; //测试显示情况</p><p class="content_105">img = QImage（（const unsigned char*）（dstImage.data）,dstImage.cols,dstImage.rows, dstImage.cols*dstImage.channels（）,QImage::Format_Indexed8）;</p><p class="content_105">// img=img.scaled（ui-＞label1-＞size（））; //调整大小</p><p class="content_105">ui-＞label2-＞setPixmap（QPixmap::fromImage（img））;</p><p class="content_104">}</p><h3 class="thirdTitle" id="bw37">2.3.8 帮助</h3><p class="content" style="text-indent:2em;">本部分的菜单主要包含版权、关于等信息，更详细的设计信息请参考附录 B部分。其部分示例如图2-61所示。</p><div class="pic"><img data-is-loaded="true" height="160" src="./images/29952-0110-0123.jpg" style="vertical-align: middle; width: 649px; height: 160px; cursor: pointer; break-inside: avoid; object-fit: contain; display: block; margin: auto;" width="649"/><p class="imgtitle" style="text-align:center;">图2-61 帮助示例</p></div></div></body></html>